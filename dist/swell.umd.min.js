(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.swell = factory());
})(this, (function () { 'use strict';

	function getAugmentedNamespace(n) {
	  var f = n.default;
		if (typeof f == "function") {
			var a = function () {
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	var shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = shams;

	var hasSymbols$1 = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr$1 = Object.prototype.toString;
	var funcType = '[object Function]';

	var implementation$1 = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr$1.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};

	var implementation = implementation$1;

	var functionBind = Function.prototype.bind || implementation;

	var bind$1 = functionBind;

	var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);

	var undefined$1;

	var $SyntaxError = SyntaxError;
	var $Function = Function;
	var $TypeError$1 = TypeError;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}

	var throwTypeError = function () {
		throw new $TypeError$1();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = hasSymbols$1();

	var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': EvalError,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': Object,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': RangeError,
		'%ReferenceError%': ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError$1,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
	};

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = functionBind;
	var hasOwn$1 = src;
	var $concat = bind.call(Function.call, Array.prototype.concat);
	var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
	var $replace = bind.call(Function.call, String.prototype.replace);
	var $strSlice = bind.call(Function.call, String.prototype.slice);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar$1 = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath$1 = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName$1, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar$1, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn$1(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError$1('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	var getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError$1('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError$1('"allowMissing" argument must be a boolean');
		}

		var parts = stringToPath$1(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError$1('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void undefined$1;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn$1(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};

	var callBind$1 = {exports: {}};

	(function (module) {

		var bind = functionBind;
		var GetIntrinsic = getIntrinsic;

		var $apply = GetIntrinsic('%Function.prototype.apply%');
		var $call = GetIntrinsic('%Function.prototype.call%');
		var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

		var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
		var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
		var $max = GetIntrinsic('%Math.max%');

		if ($defineProperty) {
			try {
				$defineProperty({}, 'a', { value: 1 });
			} catch (e) {
				// IE 8 has a broken defineProperty
				$defineProperty = null;
			}
		}

		module.exports = function callBind(originalFunction) {
			var func = $reflectApply(bind, $call, arguments);
			if ($gOPD && $defineProperty) {
				var desc = $gOPD(func, 'length');
				if (desc.configurable) {
					// original length, plus the receiver, minus any additional arguments (after the receiver)
					$defineProperty(
						func,
						'length',
						{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
					);
				}
			}
			return func;
		};

		var applyBind = function applyBind() {
			return $reflectApply(bind, $apply, arguments);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		}
	} (callBind$1));

	var GetIntrinsic$1 = getIntrinsic;

	var callBind = callBind$1.exports;

	var $indexOf = callBind(GetIntrinsic$1('String.prototype.indexOf'));

	var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic$1(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$1 = {}.toString;

	var isArray$6 = Array.isArray || function (arr) {
	  return toString$1.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$3.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	function kMaxLength () {
	  return Buffer$3.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$3.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$3(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$3 (arg, encodingOrOffset, length) {
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$3)) {
	    return new Buffer$3(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe$1(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$3.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$3._augment = function (arr) {
	  arr.__proto__ = Buffer$3.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$3.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	  Buffer$3.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$3.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$3.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe$1 (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$3.allocUnsafe = function (size) {
	  return allocUnsafe$1(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$3.allocUnsafeSlow = function (size) {
	  return allocUnsafe$1(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$3.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$3.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$6(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer$3.isBuffer = isBuffer$3;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$3.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$3.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$3.concat = function concat (list, length) {
	  if (!isArray$6(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$3.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$3.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$3.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$3.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$3.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$3.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$3.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$3.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$3.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$3.compare(this, b) === 0
	};

	Buffer$3.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$3.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$3.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$3.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$3.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$3.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$3.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$3.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$3.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$3.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$3.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$3(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$3.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$3.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$3.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$3.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$3.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$3.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$3.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$3.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$3.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$3.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$3.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$3.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$3.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$3.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$3.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$3.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$3.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$3.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$3.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$3.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$3.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$3.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$3.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$3.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$3.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$3.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$3.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$3.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$3.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$3.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$3.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$3.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$3.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$3.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$3(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$3(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop$1() {}

	var on = noop$1;
	var addListener = noop$1;
	var once = noop$1;
	var off = noop$1;
	var removeListener = noop$1;
	var removeAllListeners = noop$1;
	var emit = noop$1;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var inherits;
	if (typeof Object.create === 'function'){
	  inherits = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$1 = inherits;

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString$1(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect$1(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject$2(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect$1(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (browser$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (browser$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (browser$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = browser$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect$1(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean$1(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect$1.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect$1.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect$1.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect$1.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction$2(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect$1 &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString$1(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError$1(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction$2(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp$2(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate$1(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError$1(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$5(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction$2(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp$2(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate$1(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError$1(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp$2(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString$1(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber$1(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean$1(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$d(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$d(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$5(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean$1(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNullOrUndefined(arg) {
	  return arg == null;
	}

	function isNumber$1(arg) {
	  return typeof arg === 'number';
	}

	function isString$1(arg) {
	  return typeof arg === 'string';
	}

	function isSymbol$2(arg) {
	  return typeof arg === 'symbol';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp$2(re) {
	  return isObject$2(re) && objectToString$2(re) === '[object RegExp]';
	}

	function isObject$2(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate$1(d) {
	  return isObject$2(d) && objectToString$2(d) === '[object Date]';
	}

	function isError$1(e) {
	  return isObject$2(e) &&
	      (objectToString$2(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction$2(arg) {
	  return typeof arg === 'function';
	}

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}

	function isBuffer$2(maybeBuf) {
	  return Buffer$3.isBuffer(maybeBuf);
	}

	function objectToString$2(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	function log() {
	  console.log('%s - %s', timestamp(), format.apply(null, arguments));
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject$2(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$d(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var _polyfillNode_util = {
	  inherits: inherits$1,
	  _extend: _extend,
	  log: log,
	  isBuffer: isBuffer$2,
	  isPrimitive: isPrimitive,
	  isFunction: isFunction$2,
	  isError: isError$1,
	  isDate: isDate$1,
	  isObject: isObject$2,
	  isRegExp: isRegExp$2,
	  isUndefined: isUndefined,
	  isSymbol: isSymbol$2,
	  isString: isString$1,
	  isNumber: isNumber$1,
	  isNullOrUndefined: isNullOrUndefined,
	  isNull: isNull,
	  isBoolean: isBoolean$1,
	  isArray: isArray$5,
	  inspect: inspect$1,
	  deprecate: deprecate,
	  format: format,
	  debuglog: debuglog
	};

	var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		format: format,
		deprecate: deprecate,
		debuglog: debuglog,
		inspect: inspect$1,
		isArray: isArray$5,
		isBoolean: isBoolean$1,
		isNull: isNull,
		isNullOrUndefined: isNullOrUndefined,
		isNumber: isNumber$1,
		isString: isString$1,
		isSymbol: isSymbol$2,
		isUndefined: isUndefined,
		isRegExp: isRegExp$2,
		isObject: isObject$2,
		isDate: isDate$1,
		isError: isError$1,
		isFunction: isFunction$2,
		isPrimitive: isPrimitive,
		isBuffer: isBuffer$2,
		log: log,
		inherits: inherits$1,
		_extend: _extend,
		'default': _polyfillNode_util
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

	var util_inspect = require$$0.inspect;

	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
	var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
	var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
	var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
	var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
	var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString$1 = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var match = String.prototype.match;
	var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
	var isEnumerable = Object.prototype.propertyIsEnumerable;

	var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
	    [].__proto__ === Array.prototype // eslint-disable-line no-proto
	        ? function (O) {
	            return O.__proto__; // eslint-disable-line no-proto
	        }
	        : null
	);

	var inspectCustom = util_inspect.custom;
	var inspectSymbol = inspectCustom && isSymbol$1(inspectCustom) ? inspectCustom : null;
	var toStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag !== 'undefined' ? Symbol.toStringTag : null;

	var objectInspect = function inspect_(obj, options, depth, seen) {
	    var opts = options || {};

	    if (has$3(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
	        throw new TypeError('option "quoteStyle" must be "single" or "double"');
	    }
	    if (
	        has$3(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
	            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
	            : opts.maxStringLength !== null
	        )
	    ) {
	        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
	    }
	    var customInspect = has$3(opts, 'customInspect') ? opts.customInspect : true;
	    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
	        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
	    }

	    if (
	        has$3(opts, 'indent')
	        && opts.indent !== null
	        && opts.indent !== '\t'
	        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
	    ) {
	        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
	    }

	    if (typeof obj === 'undefined') {
	        return 'undefined';
	    }
	    if (obj === null) {
	        return 'null';
	    }
	    if (typeof obj === 'boolean') {
	        return obj ? 'true' : 'false';
	    }

	    if (typeof obj === 'string') {
	        return inspectString(obj, opts);
	    }
	    if (typeof obj === 'number') {
	        if (obj === 0) {
	            return Infinity / obj > 0 ? '0' : '-0';
	        }
	        return String(obj);
	    }
	    if (typeof obj === 'bigint') {
	        return String(obj) + 'n';
	    }

	    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
	    if (typeof depth === 'undefined') { depth = 0; }
	    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
	        return isArray$4(obj) ? '[Array]' : '[Object]';
	    }

	    var indent = getIndent(opts, depth);

	    if (typeof seen === 'undefined') {
	        seen = [];
	    } else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }

	    function inspect(value, from, noIndent) {
	        if (from) {
	            seen = seen.slice();
	            seen.push(from);
	        }
	        if (noIndent) {
	            var newOpts = {
	                depth: opts.depth
	            };
	            if (has$3(opts, 'quoteStyle')) {
	                newOpts.quoteStyle = opts.quoteStyle;
	            }
	            return inspect_(value, newOpts, depth + 1, seen);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }

	    if (typeof obj === 'function') {
	        var name = nameOf(obj);
	        var keys = arrObjKeys(obj, inspect);
	        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');
	    }
	    if (isSymbol$1(obj)) {
	        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
	        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
	    }
	    if (isElement(obj)) {
	        var s = '<' + String(obj.nodeName).toLowerCase();
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
	        s += '</' + String(obj.nodeName).toLowerCase() + '>';
	        return s;
	    }
	    if (isArray$4(obj)) {
	        if (obj.length === 0) { return '[]'; }
	        var xs = arrObjKeys(obj, inspect);
	        if (indent && !singleLineValues(xs)) {
	            return '[' + indentedJoin(xs, indent) + ']';
	        }
	        return '[ ' + xs.join(', ') + ' ]';
	    }
	    if (isError(obj)) {
	        var parts = arrObjKeys(obj, inspect);
	        if (parts.length === 0) { return '[' + String(obj) + ']'; }
	        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
	    }
	    if (typeof obj === 'object' && customInspect) {
	        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
	            return obj[inspectSymbol]();
	        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
	            return obj.inspect();
	        }
	    }
	    if (isMap$1(obj)) {
	        var mapParts = [];
	        mapForEach.call(obj, function (value, key) {
	            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
	        });
	        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
	    }
	    if (isSet$1(obj)) {
	        var setParts = [];
	        setForEach.call(obj, function (value) {
	            setParts.push(inspect(value, obj));
	        });
	        return collectionOf('Set', setSize.call(obj), setParts, indent);
	    }
	    if (isWeakMap(obj)) {
	        return weakCollectionOf('WeakMap');
	    }
	    if (isWeakSet(obj)) {
	        return weakCollectionOf('WeakSet');
	    }
	    if (isWeakRef(obj)) {
	        return weakCollectionOf('WeakRef');
	    }
	    if (isNumber(obj)) {
	        return markBoxed(inspect(Number(obj)));
	    }
	    if (isBigInt(obj)) {
	        return markBoxed(inspect(bigIntValueOf.call(obj)));
	    }
	    if (isBoolean(obj)) {
	        return markBoxed(booleanValueOf.call(obj));
	    }
	    if (isString(obj)) {
	        return markBoxed(inspect(String(obj)));
	    }
	    if (!isDate(obj) && !isRegExp$1(obj)) {
	        var ys = arrObjKeys(obj, inspect);
	        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
	        var protoTag = obj instanceof Object ? '' : 'null prototype';
	        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';
	        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
	        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');
	        if (ys.length === 0) { return tag + '{}'; }
	        if (indent) {
	            return tag + '{' + indentedJoin(ys, indent) + '}';
	        }
	        return tag + '{ ' + ys.join(', ') + ' }';
	    }
	    return String(obj);
	};

	function wrapQuotes(s, defaultStyle, opts) {
	    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
	    return quoteChar + s + quoteChar;
	}

	function quote(s) {
	    return String(s).replace(/"/g, '&quot;');
	}

	function isArray$4(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isRegExp$1(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

	// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
	function isSymbol$1(obj) {
	    if (hasShammedSymbols) {
	        return obj && typeof obj === 'object' && obj instanceof Symbol;
	    }
	    if (typeof obj === 'symbol') {
	        return true;
	    }
	    if (!obj || typeof obj !== 'object' || !symToString) {
	        return false;
	    }
	    try {
	        symToString.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isBigInt(obj) {
	    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
	        return false;
	    }
	    try {
	        bigIntValueOf.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has$3(obj, key) {
	    return hasOwn.call(obj, key);
	}

	function toStr(obj) {
	    return objectToString$1.call(obj);
	}

	function nameOf(f) {
	    if (f.name) { return f.name; }
	    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
	    if (m) { return m[1]; }
	    return null;
	}

	function indexOf(xs, x) {
	    if (xs.indexOf) { return xs.indexOf(x); }
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) { return i; }
	    }
	    return -1;
	}

	function isMap$1(x) {
	    if (!mapSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        try {
	            setSize.call(x);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof Map; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakMap(x) {
	    if (!weakMapHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakMapHas.call(x, weakMapHas);
	        try {
	            weakSetHas.call(x, weakSetHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakRef(x) {
	    if (!weakRefDeref || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakRefDeref.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isSet$1(x) {
	    if (!setSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        try {
	            mapSize.call(x);
	        } catch (m) {
	            return true;
	        }
	        return x instanceof Set; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakSet(x) {
	    if (!weakSetHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakSetHas.call(x, weakSetHas);
	        try {
	            weakMapHas.call(x, weakMapHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isElement(x) {
	    if (!x || typeof x !== 'object') { return false; }
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
	}

	function inspectString(str, opts) {
	    if (str.length > opts.maxStringLength) {
	        var remaining = str.length - opts.maxStringLength;
	        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
	        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
	    }
	    // eslint-disable-next-line no-control-regex
	    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
	    return wrapQuotes(s, 'single', opts);
	}

	function lowbyte(c) {
	    var n = c.charCodeAt(0);
	    var x = {
	        8: 'b',
	        9: 't',
	        10: 'n',
	        12: 'f',
	        13: 'r'
	    }[n];
	    if (x) { return '\\' + x; }
	    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
	}

	function markBoxed(str) {
	    return 'Object(' + str + ')';
	}

	function weakCollectionOf(type) {
	    return type + ' { ? }';
	}

	function collectionOf(type, size, entries, indent) {
	    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
	    return type + ' (' + size + ') {' + joinedEntries + '}';
	}

	function singleLineValues(xs) {
	    for (var i = 0; i < xs.length; i++) {
	        if (indexOf(xs[i], '\n') >= 0) {
	            return false;
	        }
	    }
	    return true;
	}

	function getIndent(opts, depth) {
	    var baseIndent;
	    if (opts.indent === '\t') {
	        baseIndent = '\t';
	    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
	        baseIndent = Array(opts.indent + 1).join(' ');
	    } else {
	        return null;
	    }
	    return {
	        base: baseIndent,
	        prev: Array(depth + 1).join(baseIndent)
	    };
	}

	function indentedJoin(xs, indent) {
	    if (xs.length === 0) { return ''; }
	    var lineJoiner = '\n' + indent.prev + indent.base;
	    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
	}

	function arrObjKeys(obj, inspect) {
	    var isArr = isArray$4(obj);
	    var xs = [];
	    if (isArr) {
	        xs.length = obj.length;
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has$3(obj, i) ? inspect(obj[i], obj) : '';
	        }
	    }
	    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
	    var symMap;
	    if (hasShammedSymbols) {
	        symMap = {};
	        for (var k = 0; k < syms.length; k++) {
	            symMap['$' + syms[k]] = syms[k];
	        }
	    }

	    for (var key in obj) { // eslint-disable-line no-restricted-syntax
	        if (!has$3(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
	            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
	            continue; // eslint-disable-line no-restricted-syntax, no-continue
	        } else if ((/[^\w$]/).test(key)) {
	            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
	        } else {
	            xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	    }
	    if (typeof gOPS === 'function') {
	        for (var j = 0; j < syms.length; j++) {
	            if (isEnumerable.call(obj, syms[j])) {
	                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
	            }
	        }
	    }
	    return xs;
	}

	var GetIntrinsic = getIntrinsic;
	var callBound = callBound$1;
	var inspect = objectInspect;

	var $TypeError = GetIntrinsic('%TypeError%');
	var $WeakMap = GetIntrinsic('%WeakMap%', true);
	var $Map = GetIntrinsic('%Map%', true);

	var $weakMapGet = callBound('WeakMap.prototype.get', true);
	var $weakMapSet = callBound('WeakMap.prototype.set', true);
	var $weakMapHas = callBound('WeakMap.prototype.has', true);
	var $mapGet = callBound('Map.prototype.get', true);
	var $mapSet = callBound('Map.prototype.set', true);
	var $mapHas = callBound('Map.prototype.has', true);

	/*
	 * This function traverses the list returning the node corresponding to the
	 * given key.
	 *
	 * That node is also moved to the head of the list, so that if it's accessed
	 * again we don't need to traverse the whole list. By doing so, all the recently
	 * used nodes can be accessed relatively quickly.
	 */
	var listGetNode = function (list, key) { // eslint-disable-line consistent-return
		for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
			if (curr.key === key) {
				prev.next = curr.next;
				curr.next = list.next;
				list.next = curr; // eslint-disable-line no-param-reassign
				return curr;
			}
		}
	};

	var listGet = function (objects, key) {
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	var listSet = function (objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) {
			node.value = value;
		} else {
			// Prepend the new node to the beginning of the list
			objects.next = { // eslint-disable-line no-param-reassign
				key: key,
				next: objects.next,
				value: value
			};
		}
	};
	var listHas = function (objects, key) {
		return !!listGetNode(objects, key);
	};

	var sideChannel = function getSideChannel() {
		var $wm;
		var $m;
		var $o;
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			get: function (key) { // eslint-disable-line consistent-return
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapGet($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listGet($o, key);
					}
				}
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapHas($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listHas($o, key);
					}
				}
				return false;
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if ($Map) {
					if (!$m) {
						$m = new $Map();
					}
					$mapSet($m, key, value);
				} else {
					if (!$o) {
						/*
						 * Initialize the linked list as an empty node, so that we don't have
						 * to special-case handling of the first node: we can always refer to
						 * it as (previous node).next, instead of something like (list).head
						 */
						$o = { key: {}, next: null };
					}
					listSet($o, key, value);
				}
			}
		};
		return channel;
	};

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	var Format = {
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};

	var formats$3 = {
	    'default': Format.RFC3986,
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return String(value);
	        }
	    },
	    RFC1738: Format.RFC1738,
	    RFC3986: Format.RFC3986
	};

	var formats$2 = formats$3;

	var has$2 = Object.prototype.hasOwnProperty;
	var isArray$3 = Array.isArray;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	var compactQueue = function compactQueue(queue) {
	    while (queue.length > 1) {
	        var item = queue.pop();
	        var obj = item.obj[item.prop];

	        if (isArray$3(obj)) {
	            var compacted = [];

	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }

	            item.obj[item.prop] = compacted;
	        }
	    }
	};

	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	var merge$1 = function merge(target, source, options) {
	    /* eslint no-param-reassign: 0 */
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (isArray$3(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if ((options && (options.plainObjects || options.allowPrototypes)) || !has$2.call(Object.prototype, source)) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (isArray$3(target) && !isArray$3(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }

	    if (isArray$3(target) && isArray$3(source)) {
	        source.forEach(function (item, i) {
	            if (has$2.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (has$2.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};

	var decode = function (str, decoder, charset) {
	    var strWithoutPlus = str.replace(/\+/g, ' ');
	    if (charset === 'iso-8859-1') {
	        // unescape never throws, no try...catch needed:
	        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	    }
	    // utf-8
	    try {
	        return decodeURIComponent(strWithoutPlus);
	    } catch (e) {
	        return strWithoutPlus;
	    }
	};

	var encode = function encode(str, defaultEncoder, charset, kind, format) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = str;
	    if (typeof str === 'symbol') {
	        string = Symbol.prototype.toString.call(str);
	    } else if (typeof str !== 'string') {
	        string = String(str);
	    }

	    if (charset === 'iso-8859-1') {
	        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
	            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
	        });
	    }

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D // -
	            || c === 0x2E // .
	            || c === 0x5F // _
	            || c === 0x7E // ~
	            || (c >= 0x30 && c <= 0x39) // 0-9
	            || (c >= 0x41 && c <= 0x5A) // a-z
	            || (c >= 0x61 && c <= 0x7A) // A-Z
	            || (format === formats$2.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        /* eslint operator-linebreak: [2, "before"] */
	        out += hexTable[0xF0 | (c >> 18)]
	            + hexTable[0x80 | ((c >> 12) & 0x3F)]
	            + hexTable[0x80 | ((c >> 6) & 0x3F)]
	            + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];

	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];

	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }

	    compactQueue(queue);

	    return value;
	};

	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	var isBuffer$1 = function isBuffer(obj) {
	    if (!obj || typeof obj !== 'object') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

	var combine = function combine(a, b) {
	    return [].concat(a, b);
	};

	var maybeMap = function maybeMap(val, fn) {
	    if (isArray$3(val)) {
	        var mapped = [];
	        for (var i = 0; i < val.length; i += 1) {
	            mapped.push(fn(val[i]));
	        }
	        return mapped;
	    }
	    return fn(val);
	};

	var utils$3 = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    combine: combine,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer$1,
	    isRegExp: isRegExp,
	    maybeMap: maybeMap,
	    merge: merge$1
	};

	var getSideChannel = sideChannel;
	var utils$2 = utils$3;
	var formats$1 = formats$3;
	var has$1 = Object.prototype.hasOwnProperty;

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    comma: 'comma',
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var isArray$2 = Array.isArray;
	var split = String.prototype.split;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
	};

	var toISO = Date.prototype.toISOString;

	var defaultFormat = formats$1['default'];
	var defaults$1 = {
	    addQueryPrefix: false,
	    allowDots: false,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    delimiter: '&',
	    encode: true,
	    encoder: utils$2.encode,
	    encodeValuesOnly: false,
	    format: defaultFormat,
	    formatter: formats$1.formatters[defaultFormat],
	    // deprecated
	    indices: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
	    return typeof v === 'string'
	        || typeof v === 'number'
	        || typeof v === 'boolean'
	        || typeof v === 'symbol'
	        || typeof v === 'bigint';
	};

	var sentinel = {};

	var stringify$1 = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    strictNullHandling,
	    skipNulls,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    format,
	    formatter,
	    encodeValuesOnly,
	    charset,
	    sideChannel
	) {
	    var obj = object;

	    var tmpSc = sideChannel;
	    var step = 0;
	    var findFlag = false;
	    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
	        // Where object last appeared in the ref tree
	        var pos = tmpSc.get(object);
	        step += 1;
	        if (typeof pos !== 'undefined') {
	            if (pos === step) {
	                throw new RangeError('Cyclic object value');
	            } else {
	                findFlag = true; // Break while
	            }
	        }
	        if (typeof tmpSc.get(sentinel) === 'undefined') {
	            step = 0;
	        }
	    }

	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
	        obj = utils$2.maybeMap(obj, function (value) {
	            if (value instanceof Date) {
	                return serializeDate(value);
	            }
	            return value;
	        });
	    }

	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, 'key', format) : prefix;
	        }

	        obj = '';
	    }

	    if (isNonNullishPrimitive(obj) || utils$2.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, 'key', format);
	            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
	                var valuesArray = split.call(String(obj), ',');
	                var valuesJoined = '';
	                for (var i = 0; i < valuesArray.length; ++i) {
	                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults$1.encoder, charset, 'value', format));
	                }
	                return [formatter(keyValue) + '=' + valuesJoined];
	            }
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder, charset, 'value', format))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
	        // we need to join elements in
	        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
	    } else if (isArray$2(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var j = 0; j < objKeys.length; ++j) {
	        var key = objKeys[j];
	        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

	        if (skipNulls && value === null) {
	            continue;
	        }

	        var keyPrefix = isArray$2(obj)
	            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
	            : prefix + (allowDots ? '.' + key : '[' + key + ']');

	        sideChannel.set(object, step);
	        var valueSideChannel = getSideChannel();
	        valueSideChannel.set(sentinel, sideChannel);
	        pushToArray(values, stringify(
	            value,
	            keyPrefix,
	            generateArrayPrefix,
	            strictNullHandling,
	            skipNulls,
	            encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            format,
	            formatter,
	            encodeValuesOnly,
	            charset,
	            valueSideChannel
	        ));
	    }

	    return values;
	};

	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
	    if (!opts) {
	        return defaults$1;
	    }

	    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    var charset = opts.charset || defaults$1.charset;
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }

	    var format = formats$1['default'];
	    if (typeof opts.format !== 'undefined') {
	        if (!has$1.call(formats$1.formatters, opts.format)) {
	            throw new TypeError('Unknown format option provided.');
	        }
	        format = opts.format;
	    }
	    var formatter = formats$1.formatters[format];

	    var filter = defaults$1.filter;
	    if (typeof opts.filter === 'function' || isArray$2(opts.filter)) {
	        filter = opts.filter;
	    }

	    return {
	        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
	        delimiter: typeof opts.delimiter === 'undefined' ? defaults$1.delimiter : opts.delimiter,
	        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$1.encode,
	        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$1.encoder,
	        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
	        filter: filter,
	        format: format,
	        formatter: formatter,
	        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$1.serializeDate,
	        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$1.skipNulls,
	        sort: typeof opts.sort === 'function' ? opts.sort : null,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
	    };
	};

	var stringify_1 = function (object, opts) {
	    var obj = object;
	    var options = normalizeStringifyOptions(opts);

	    var objKeys;
	    var filter;

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray$2(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = opts.arrayFormat;
	    } else if (opts && 'indices' in opts) {
	        arrayFormat = opts.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (options.sort) {
	        objKeys.sort(options.sort);
	    }

	    var sideChannel = getSideChannel();
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (options.skipNulls && obj[key] === null) {
	            continue;
	        }
	        pushToArray(keys, stringify$1(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            options.strictNullHandling,
	            options.skipNulls,
	            options.encode ? options.encoder : null,
	            options.filter,
	            options.sort,
	            options.allowDots,
	            options.serializeDate,
	            options.format,
	            options.formatter,
	            options.encodeValuesOnly,
	            options.charset,
	            sideChannel
	        ));
	    }

	    var joined = keys.join(options.delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';

	    if (options.charsetSentinel) {
	        if (options.charset === 'iso-8859-1') {
	            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
	            prefix += 'utf8=%26%2310003%3B&';
	        } else {
	            // encodeURIComponent('✓')
	            prefix += 'utf8=%E2%9C%93&';
	        }
	    }

	    return joined.length > 0 ? prefix + joined : '';
	};

	var utils$1 = utils$3;

	var has = Object.prototype.hasOwnProperty;
	var isArray$1 = Array.isArray;

	var defaults = {
	    allowDots: false,
	    allowPrototypes: false,
	    allowSparse: false,
	    arrayLimit: 20,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    comma: false,
	    decoder: utils$1.decode,
	    delimiter: '&',
	    depth: 5,
	    ignoreQueryPrefix: false,
	    interpretNumericEntities: false,
	    parameterLimit: 1000,
	    parseArrays: true,
	    plainObjects: false,
	    strictNullHandling: false
	};

	var interpretNumericEntities = function (str) {
	    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
	        return String.fromCharCode(parseInt(numberStr, 10));
	    });
	};

	var parseArrayValue = function (val, options) {
	    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
	        return val.split(',');
	    }

	    return val;
	};

	// This is what browsers will submit when the ✓ character occurs in an
	// application/x-www-form-urlencoded body and the encoding of the page containing
	// the form is iso-8859-1, or when the submitted form has an accept-charset
	// attribute of iso-8859-1. Presumably also with other charsets that do not contain
	// the ✓ character, such as us-ascii.
	var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

	// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
	var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = {};
	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(options.delimiter, limit);
	    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
	    var i;

	    var charset = options.charset;
	    if (options.charsetSentinel) {
	        for (i = 0; i < parts.length; ++i) {
	            if (parts[i].indexOf('utf8=') === 0) {
	                if (parts[i] === charsetSentinel) {
	                    charset = 'utf-8';
	                } else if (parts[i] === isoSentinel) {
	                    charset = 'iso-8859-1';
	                }
	                skipIndex = i;
	                i = parts.length; // The eslint settings do not allow break;
	            }
	        }
	    }

	    for (i = 0; i < parts.length; ++i) {
	        if (i === skipIndex) {
	            continue;
	        }
	        var part = parts[i];

	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder, charset, 'key');
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
	            val = utils$1.maybeMap(
	                parseArrayValue(part.slice(pos + 1), options),
	                function (encodedVal) {
	                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
	                }
	            );
	        }

	        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
	            val = interpretNumericEntities(val);
	        }

	        if (part.indexOf('[]=') > -1) {
	            val = isArray$1(val) ? [val] : val;
	        }

	        if (has.call(obj, key)) {
	            obj[key] = utils$1.combine(obj[key], val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function (chain, val, options, valuesParsed) {
	    var leaf = valuesParsed ? val : parseArrayValue(val, options);

	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];

	        if (root === '[]' && options.parseArrays) {
	            obj = [].concat(leaf);
	        } else {
	            obj = options.plainObjects ? Object.create(null) : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var index = parseInt(cleanRoot, 10);
	            if (!options.parseArrays && cleanRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== cleanRoot
	                && String(index) === cleanRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else if (cleanRoot !== '__proto__') {
	                obj[cleanRoot] = leaf;
	            }
	        }

	        leaf = obj;
	    }

	    return leaf;
	};

	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;

	    // Get the parent

	    var segment = options.depth > 0 && brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;

	    // Stash the parent if it exists

	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(parent);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options, valuesParsed);
	};

	var normalizeParseOptions = function normalizeParseOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }
	    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

	    return {
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
	        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
	        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
	        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
	        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
	        delimiter: typeof opts.delimiter === 'string' || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
	        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
	        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
	        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
	        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
	        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
	        parseArrays: opts.parseArrays !== false,
	        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	var parse$1 = function (str, opts) {
	    var options = normalizeParseOptions(opts);

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
	        obj = utils$1.merge(obj, newObj, options);
	    }

	    if (options.allowSparse === true) {
	        return obj;
	    }

	    return utils$1.compact(obj);
	};

	var stringify = stringify_1;
	var parse = parse$1;
	var formats = formats$3;

	var lib = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global$1 == 'object' && global$1 && global$1.Object === Object && global$1;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Built-in value references. */
	var Symbol$1 = root.Symbol;

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$f.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$e.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$1(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$1(value) {
	  if (!isObject$1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
	}

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$d = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject$1(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var symbolTag$3 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
	}

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
	}

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/* Built-in method references that are verified to be native. */
	var Map$1 = getNative(root, 'Map');

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$1 || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$3 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$2 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
	}

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject$1(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	      return object;
	    }

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject$1(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/* Built-in method references that are verified to be native. */
	var Set$1 = getNative(root, 'Set');

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY$1) ? noop : function(values) {
	  return new Set$1(values);
	};

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$1 = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE$1) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? baseUniq(array) : [];
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/** Built-in value references. */
	var Uint8Array$1 = root.Uint8Array;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;

	/** `Object#toString` result references. */
	var boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    mapTag$6 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$6 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$2 = '[object Symbol]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$4:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$3:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$3:
	    case dateTag$3:
	    case numberTag$3:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag$2:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$3:
	    case stringTag$3:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$6:
	      var convert = mapToArray;

	    case setTag$6:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$2;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$2:
	      if (symbolValueOf$1) {
	        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
	}

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	/** Detect free variable `exports`. */
	var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

	/** Built-in value references. */
	var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag$5 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$3 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$2 = '[object String]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
	typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
	typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
	typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
	typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
	typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
	typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
	typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag$5] = typedArrayTags[numberTag$2] =
	typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] =
	typedArrayTags[setTag$5] = typedArrayTags[stringTag$2] =
	typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

	  return value === proto;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction$1(value);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative(root, 'DataView');

	/* Built-in method references that are verified to be native. */
	var Promise$1 = getNative(root, 'Promise');

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = getNative(root, 'WeakMap');

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]',
	    objectTag$2 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$4 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$2 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView$1),
	    mapCtorString = toSource(Map$1),
	    promiseCtorString = toSource(Promise$1),
	    setCtorString = toSource(Set$1),
	    weakMapCtorString = toSource(WeakMap$1);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2) ||
	    (Map$1 && getTag(new Map$1) != mapTag$4) ||
	    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
	    (Set$1 && getTag(new Set$1) != setTag$4) ||
	    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag$2 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$2;
	        case mapCtorString: return mapTag$4;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$4;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var getTag$1 = getTag;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
	      othTag = othIsArr ? arrayTag$1 : getTag$1(other);

	  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
	  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;

	  var objIsObj = objTag == objectTag$1,
	      othIsObj = othTag == objectTag$1,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$3.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject$1(value);
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	/** Used to match a single whitespace character. */
	var reWhitespace = /\s/;

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */
	function trimmedEndIndex(string) {
	  var index = string.length;

	  while (index-- && reWhitespace.test(string.charAt(index))) {}
	  return index;
	}

	/** Used to match leading whitespace. */
	var reTrimStart = /^\s+/;

	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */
	function baseTrim(string) {
	  return string
	    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	    : string;
	}

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject$1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = baseTrim(value);
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$1 = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax$1(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate), index);
	}

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsFinite = root.isFinite,
	    nativeMin = Math.min;

	/**
	 * Creates a function like `_.round`.
	 *
	 * @private
	 * @param {string} methodName The name of the `Math` method to use when rounding.
	 * @returns {Function} Returns the new round function.
	 */
	function createRound(methodName) {
	  var func = Math[methodName];
	  return function(number, precision) {
	    number = toNumber(number);
	    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	    if (precision && nativeIsFinite(number)) {
	      // Shift with exponential notation to avoid floating-point issues.
	      // See [MDN](https://mdn.io/round#Examples) for more details.
	      var pair = (toString(number) + 'e').split('e'),
	          value = func(pair[0] + 'e' + (+pair[1] + precision));

	      pair = (toString(value) + 'e').split('e');
	      return +(pair[0] + 'e' + (+pair[1] - precision));
	    }
	    return func(number);
	  };
	}

	/**
	 * Computes `number` rounded to `precision`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.10.0
	 * @category Math
	 * @param {number} number The number to round.
	 * @param {number} [precision=0] The precision to round to.
	 * @returns {number} Returns the rounded number.
	 * @example
	 *
	 * _.round(4.006);
	 * // => 4
	 *
	 * _.round(4.006, 2);
	 * // => 4.01
	 *
	 * _.round(4060, -2);
	 * // => 4100
	 */
	var round = createRound('round');

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, paths, predicate) {
	  var index = -1,
	      length = paths.length,
	      result = {};

	  while (++index < length) {
	    var path = paths[index],
	        value = baseGet(object, path);

	    if (predicate(value, path)) {
	      baseSet(result, castPath(path, object), value);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.pick` without support for individual
	 * property identifiers.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Object} Returns the new object.
	 */
	function basePick(object, paths) {
	  return basePickBy(object, paths, function(value, path) {
	    return hasIn(object, path);
	  });
	}

	/** Built-in value references. */
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten), func + '');
	}

	/**
	 * Creates an object composed of the picked `object` properties.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pick(object, ['a', 'c']);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var pick = flatRest(function(object, paths) {
	  return object == null ? {} : basePick(object, paths);
	});

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject$1(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer$1 = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$1.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$3 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$3 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$1:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray(object, isDeep);

	    case mapTag$3:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return cloneRegExp(object);

	    case setTag$3:
	      return new Ctor;

	    case symbolTag$1:
	      return cloneSymbol(object);
	  }
	}

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag$1(value) == mapTag$2;
	}

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	/** `Object#toString` result references. */
	var setTag$2 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag$1(value) == setTag$2;
	}

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag$1 = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag$1] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$1,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$1(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	/**
	 * Converts `string`, as a whole, to lower case just like
	 * [String#toLowerCase](https://mdn.io/toLowerCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the lower cased string.
	 * @example
	 *
	 * _.toLower('--Foo-Bar--');
	 * // => '--foo-bar--'
	 *
	 * _.toLower('fooBar');
	 * // => 'foobar'
	 *
	 * _.toLower('__FOO_BAR__');
	 * // => '__foo_bar__'
	 */
	function toLower(value) {
	  return toString(value).toLowerCase();
	}

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag$1(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value)
			&& !isSpecial(value)
	};

	function isNonNullObject(value) {
		return !!value && typeof value === 'object'
	}

	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);

		return stringValue === '[object RegExp]'
			|| stringValue === '[object Date]'
			|| isReactElement(value)
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE
	}

	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {}
	}

	function cloneUnlessOtherwiseSpecified(value, options) {
		return (options.clone !== false && options.isMergeableObject(value))
			? deepmerge(emptyTarget(value), value, options)
			: value
	}

	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options)
		})
	}

	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === 'function' ? customMerge : deepmerge
	}

	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
				return target.propertyIsEnumerable(symbol)
			})
			: []
	}

	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
	}

	function propertyIsOnObject(object, property) {
		try {
			return property in object
		} catch(_) {
			return false
		}
	}

	// Protects from prototype poisoning and unexpected merging up the prototype chain.
	function propertyIsUnsafe(target, key) {
		return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
			&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
				&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
	}

	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function(key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function(key) {
			if (propertyIsUnsafe(target, key)) {
				return
			}

			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			} else {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			}
		});
		return destination
	}

	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
		// implementations can use it. The caller may not replace it.
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options)
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options)
		} else {
			return mergeObject(target, source, options)
		}
	}

	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error('first argument should be an array')
		}

		return array.reduce(function(prev, next) {
			return deepmerge(prev, next, options)
		}, {})
	};

	var deepmerge_1 = deepmerge;

	var cjs = deepmerge_1;

	function t(t){return 65<=t&&t<=90}function n(t){return 97<=t&&t<=122}function r(t){return 48<=t&&t<=57}function o(t){return t-32}function e(t){return t+32}function u(u){const c=u.charCodeAt(0);if(r(c)||45===c||isNaN(c))return u;let i=t(c);const f=i?[e(c)]:[c],s=u.length;for(let t=1;t<s;t++){let r=u.charCodeAt(t);if(95===r||32===r||45===r){if(i=!0,r=u.charCodeAt(++t),isNaN(r))return u;n(r)?f.push(o(r)):f.push(r);}else f.push(r);}return i?String.fromCharCode.apply(void 0,f):u}function c(r,o){const u=r.charCodeAt(0);if(!n(u)||isNaN(u))return r;let c=!1;const i=[u];let f=95;o&&o.charCodeAt(0)&&(f=o.charCodeAt(0));const s=r.length;for(let n=1;n<s;n++){const o=r.charCodeAt(n);t(o)?(c=!0,i.push(f),i.push(e(o))):i.push(o);}return c?String.fromCharCode.apply(void 0,i):r}function s(t){return Boolean(t)&&"object"==typeof t&&!(t instanceof Function)&&!(t instanceof Date)}function a(t,n,r){if(Array.isArray(t))return function(t,n,r){const o=new Array(t.length);let e=0;for(const u of t)o[e++]=s(u)?a(u,n,r):u;return o}(t,n,r);if(void 0!==t.prototype)return t;const o={};for(const e in t){const u=t[e];o[n(e,r)]=s(u)?a(u,n,r):u;}return o}function l(t){return s(t)?a(t,u):t}function d(t,n){return s(t)?a(t,c,n):t}

	const LOADING_SCRIPTS = {};
	let options$1 = {};
	function merge(x, y, opt = {}) {
	  if (!y || typeof y !== "object") {
	    return x;
	  }
	  if (!x || typeof x !== "object") {
	    return x;
	  }
	  function arrayMerge(target, source, options2) {
	    const destination = target.slice();
	    source.forEach((item, index) => {
	      if (typeof destination[index] === "undefined") {
	        destination[index] = options2.cloneUnlessOtherwiseSpecified(
	          item,
	          options2
	        );
	      } else if (options2.isMergeableObject(item)) {
	        destination[index] = merge(target[index], item, options2);
	      } else if (target.indexOf(item) === -1) {
	        destination.push(item);
	      }
	    });
	    return destination;
	  }
	  return cjs(x, y, {
	    arrayMerge
	  });
	}
	function setOptions(optns) {
	  options$1 = optns;
	}
	function getOptions() {
	  return options$1;
	}
	function isObject(val) {
	  return val && typeof val === "object" && !(val instanceof Array);
	}
	function camelCase(str) {
	  return u(str);
	}
	function snakeCase(str) {
	  return c(str, "_");
	}
	function toCamel(obj) {
	  if (!obj)
	    return obj;
	  const objCopy = JSON.parse(JSON.stringify(obj));
	  return l(objCopy);
	}
	function toCamelPath(str) {
	  if (typeof str === "string") {
	    return str.split(".").map(u).join(".");
	  }
	  return str;
	}
	function toSnake(obj) {
	  if (!obj)
	    return obj;
	  const objCopy = JSON.parse(JSON.stringify(obj));
	  return d(objCopy, "_");
	}
	function trimBoth(str) {
	  return trimStart(trimEnd(str));
	}
	function trimStart(str) {
	  return typeof str === "string" ? str.replace(/^[/]+/, "") : "";
	}
	function trimEnd(str) {
	  return typeof str === "string" ? str.replace(/[/]+$/, "") : "";
	}
	function stringifyQuery(str) {
	  return lib.stringify(str);
	}
	function map(arr, cb) {
	  return arr instanceof Array ? arr.map(cb) : [];
	}
	function reduce(arr, cb, init) {
	  return arr instanceof Array ? arr.reduce(cb, init) : init;
	}
	function isServer() {
	  return !(typeof window !== "undefined" && window && window.document);
	}
	function isFunction(func) {
	  return typeof func === "function";
	}
	function defaultMethods(request, uri, methods) {
	  return {
	    list: methods.indexOf("list") >= 0 ? function(query) {
	      return request("get", uri, void 0, query);
	    } : void 0,
	    get: methods.indexOf("get") >= 0 ? function(id, query) {
	      return request("get", uri, id, query);
	    } : void 0
	  };
	}
	async function vaultRequest(method, url, data, opt = void 0) {
	  const vaultUrl = options$1.vaultUrl;
	  const timeout = options$1.timeout;
	  const requestId = vaultRequestId();
	  const callback = `swell_vault_response_${requestId}`;
	  data = {
	    $jsonp: {
	      method,
	      callback
	    },
	    $data: data,
	    $key: options$1.key
	  };
	  return new Promise((resolve, reject) => {
	    const script = document.createElement("script");
	    script.type = "text/javascript";
	    script.src = `${trimEnd(vaultUrl)}/${trimStart(url)}?${serializeData(
      data
    )}`;
	    const errorTimeout = setTimeout(() => {
	      window[callback]({
	        $error: `Request timed out after ${timeout / 1e3} seconds`,
	        $status: 500
	      });
	    }, timeout);
	    window[callback] = (result) => {
	      clearTimeout(errorTimeout);
	      if (result && result.$error) {
	        const err = new Error(result.$error);
	        err.code = "request_error";
	        err.status = result.$status;
	        reject(err);
	      } else if (!result || result.$status >= 300) {
	        const err = new Error(
	          "A connection error occurred while making the request"
	        );
	        err.code = "connection_error";
	        err.status = result.$status;
	        reject(err);
	      } else {
	        resolve(result.$data);
	      }
	      delete window[callback];
	      script.parentNode.removeChild(script);
	    };
	    document.getElementsByTagName("head")[0].appendChild(script);
	  });
	}
	function vaultRequestId() {
	  window.__swell_vault_request_id = window.__swell_vault_request_id || 0;
	  window.__swell_vault_request_id++;
	  return window.__swell_vault_request_id;
	}
	function serializeData(data) {
	  const s = [];
	  const add = function(key2, value) {
	    if (typeof value === "function") {
	      value = value();
	    } else if (value == null) {
	      value = "";
	    }
	    s[s.length] = encodeURIComponent(key2) + "=" + encodeURIComponent(value);
	  };
	  for (const key2 in data) {
	    buildParams(key2, data[key2], add);
	  }
	  return s.join("&").replace(" ", "+");
	}
	const rbracket = /\[\]$/;
	function buildParams(key, obj, add) {
	  let name;
	  if (obj instanceof Array) {
	    for (let i = 0; i < obj.length; i++) {
	      if (rbracket.test(key)) {
	        add(key, v);
	      } else {
	        buildParams(
	          key + "[" + (typeof v === "object" && v != null ? i : "") + "]",
	          v,
	          add
	        );
	      }
	    }
	  } else if (obj && typeof obj === "object") {
	    for (name in obj) {
	      buildParams(key + "[" + name + "]", obj[name], add);
	    }
	  } else {
	    add(key, obj);
	  }
	}
	function base64Encode(string) {
	  if (typeof btoa !== "undefined") {
	    return btoa(string);
	  }
	  return Buffer.from(string).toString("base64");
	}
	function getLocationParams(location) {
	  const url = location.search;
	  const query = url.substr(1);
	  const result = {};
	  query.split("&").forEach(function(part) {
	    const item = part.split("=");
	    result[item[0]] = decodeURIComponent(item[1]);
	  });
	  return result;
	}
	function removeUrlParams() {
	  const url = window.location.origin + window.location.pathname;
	  window.history.pushState({ path: url }, "", url);
	}
	async function loadScript(id, src, attributes = {}) {
	  LOADING_SCRIPTS[id] = LOADING_SCRIPTS[id] || new Promise((resolve) => {
	    const script = document.createElement("script");
	    script.id = id;
	    script.src = src;
	    script.async = true;
	    script.type = "text/javascript";
	    for (const [key, value] of Object.entries(attributes)) {
	      script.setAttribute(key, value);
	    }
	    script.addEventListener(
	      "load",
	      () => {
	        resolve();
	        LOADING_SCRIPTS[id] = null;
	      },
	      {
	        once: true
	      }
	    );
	    document.head.appendChild(script);
	  });
	  return LOADING_SCRIPTS[id];
	}
	function isLiveMode(mode) {
	  return mode !== "test";
	}

	var utils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		defaultMethods: defaultMethods,
		set: set,
		get: get,
		uniq: uniq,
		find: find,
		round: round,
		pick: pick,
		findIndex: findIndex,
		camelCase: camelCase,
		cloneDeep: cloneDeep,
		merge: merge,
		setOptions: setOptions,
		getOptions: getOptions,
		toCamel: toCamel,
		toCamelPath: toCamelPath,
		toSnake: toSnake,
		trimBoth: trimBoth,
		trimStart: trimStart,
		trimEnd: trimEnd,
		stringifyQuery: stringifyQuery,
		isServer: isServer,
		isFunction: isFunction,
		isObject: isObject,
		toNumber: toNumber,
		toLower: toLower,
		isEqual: isEqual,
		isEmpty: isEmpty,
		snakeCase: snakeCase,
		map: map,
		reduce: reduce,
		base64Encode: base64Encode,
		vaultRequest: vaultRequest,
		getLocationParams: getLocationParams,
		removeUrlParams: removeUrlParams,
		loadScript: loadScript,
		isLiveMode: isLiveMode
	});

	const cardApi = {
	  async createToken(data) {
	    let error = null;
	    let code = null;
	    let param = null;
	    if (!data) {
	      error = "Card details are missing in `swell.card.createToken(card)`";
	      param = "";
	    }
	    const card = toSnake(data);
	    if (!card.nonce) {
	      if (!this.validateNumber(card.number)) {
	        error = "Card number appears to be invalid";
	        code = "invalid_card_number";
	        param = "number";
	      }
	      if (card.exp) {
	        const exp = this.expiry(card.exp);
	        card.exp_month = exp.month;
	        card.exp_year = exp.year;
	      }
	      if (!this.validateExpiry(card.exp_month, card.exp_year)) {
	        error = "Card expiry appears to be invalid";
	        code = "invalid_card_expiry";
	        param = "exp_month";
	      }
	      if (!this.validateCVC(card.cvc)) {
	        error = "Card CVC code appears to be invalid";
	        code = "invalid_card_cvc";
	        param = "exp_cvc";
	      }
	    }
	    if (error) {
	      const err = new Error(error);
	      err.code = code || "invalid_card";
	      err.status = 402;
	      err.param = param;
	      throw err;
	    }
	    const result = await vaultRequest("post", "/tokens", card);
	    if (result.errors) {
	      const param2 = Object.keys(result.errors)[0];
	      const err = new Error(result.errors[param2].message || "Unknown error");
	      err.code = "vault_error";
	      err.status = 402;
	      err.param = param2;
	      throw err;
	    }
	    return result;
	  },
	  expiry(value) {
	    if (value && value.month && value.year) {
	      return value;
	    }
	    const parts = new String(value).split(/[\s\/\-]+/, 2);
	    const month = parts[0];
	    let year = parts[1];
	    if (year && year.length === 2 && /^\d+$/.test(year)) {
	      const prefix = new Date().getFullYear().toString().substring(0, 2);
	      year = prefix + year;
	    }
	    return {
	      month: ~~month,
	      year: ~~year
	    };
	  },
	  types() {
	    let e, t, n, r;
	    t = {};
	    for (e = n = 40; n <= 49; e = ++n)
	      t[e] = "Visa";
	    for (e = r = 50; r <= 59; e = ++r)
	      t[e] = "MasterCard";
	    return t[34] = t[37] = "American Express", t[60] = t[62] = t[64] = t[65] = "Discover", t[35] = "JCB", t[30] = t[36] = t[38] = t[39] = "Diners Club", t;
	  },
	  type(num) {
	    return this.types()[num.slice(0, 2)] || "Unknown";
	  },
	  luhnCheck(num) {
	    let t, n, r, i, s, o;
	    r = true, i = 0, n = (num + "").split("").reverse();
	    for (s = 0, o = n.length; s < o; s++) {
	      t = n[s], t = parseInt(t, 10);
	      if (r = !r)
	        t *= 2;
	      t > 9 && (t -= 9), i += t;
	    }
	    return i % 10 === 0;
	  },
	  validateNumber(num) {
	    return num = (num + "").replace(/\s+|-/g, ""), num.length >= 10 && num.length <= 16 && this.luhnCheck(num);
	  },
	  validateExpiry(month, year) {
	    let r, i;
	    return month = String(month).trim(), year = String(year).trim(), /^\d+$/.test(month) ? /^\d+$/.test(year) ? parseInt(month, 10) <= 12 ? (i = new Date(year, month), r = new Date(), i.setMonth(i.getMonth() - 1), i.setMonth(i.getMonth() + 1, 1), i > r) : false : false : false;
	  },
	  validateCVC(val) {
	    return val = String(val).trim(), /^\d+$/.test(val) && val.length >= 3 && val.length <= 4;
	  }
	};

	var __defProp$i = Object.defineProperty;
	var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
	var __hasOwnProp$i = Object.prototype.hasOwnProperty;
	var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$i = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$i.call(b, prop))
	      __defNormalProp$i(a, prop, b[prop]);
	  if (__getOwnPropSymbols$i)
	    for (var prop of __getOwnPropSymbols$i(b)) {
	      if (__propIsEnum$i.call(b, prop))
	        __defNormalProp$i(a, prop, b[prop]);
	    }
	  return a;
	};
	const COOKIE_MAX_AGE = 604800;
	function getCookie(name) {
	  if (isServer()) {
	    return void 0;
	  }
	  const matches = document.cookie.match(
	    new RegExp(
	      "(?:^|; )" + name.replace(/([.$?*|{}()[]\\\/\+^])/g, "\\$1") + "=([^;]*)"
	    )
	  );
	  return matches ? decodeURIComponent(matches[1]) : void 0;
	}
	function setCookie(name, value, options = {}) {
	  if (isServer()) {
	    return;
	  }
	  options = __spreadValues$i({
	    path: "/",
	    "max-age": COOKIE_MAX_AGE,
	    samesite: "lax"
	  }, options);
	  if (options.expires && options.expires.toUTCString) {
	    options.expires = options.expires.toUTCString();
	  }
	  let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
	  for (const optionKey in options) {
	    updatedCookie += "; " + optionKey;
	    const optionValue = options[optionKey];
	    if (optionValue !== true) {
	      updatedCookie += "=" + optionValue;
	    }
	  }
	  document.cookie = updatedCookie;
	}

	var __defProp$h = Object.defineProperty;
	var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
	var __hasOwnProp$h = Object.prototype.hasOwnProperty;
	var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$h = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$h.call(b, prop))
	      __defNormalProp$h(a, prop, b[prop]);
	  if (__getOwnPropSymbols$h)
	    for (var prop of __getOwnPropSymbols$h(b)) {
	      if (__propIsEnum$h.call(b, prop))
	        __defNormalProp$h(a, prop, b[prop]);
	    }
	  return a;
	};
	const RECORD_TIMEOUT = 5e3;
	let VALUES = {};
	const cacheApi = {
	  options: {
	    enabled: true,
	    debug: false
	  },
	  debug(...args) {
	    if (this.options.debug) {
	      console.log(...args);
	    }
	  },
	  values({ model, id }, setValues = void 0) {
	    this.debug("cache.values", ...arguments);
	    if (setValues !== void 0) {
	      for (let key in setValues) {
	        set(VALUES, `${model}.${id}.${key}`, setValues[key]);
	      }
	      return;
	    }
	    return get(VALUES, `${model}.${id}`, {});
	  },
	  preset(details) {
	    this.debug("cache.preset", ...arguments);
	    const { presets = [] } = this.values(details);
	    presets.push(details);
	    this.values(details, { presets });
	  },
	  set(details) {
	    this.debug("cache.set", ...arguments);
	    let { model, id, path, value } = details;
	    let { data = {}, record, presets } = this.values(details);
	    if (id === null) {
	      return;
	    }
	    if (record === void 0) {
	      return this.preset(details);
	    }
	    data = merge(record || {}, data);
	    const { useCamelCase } = getOptions();
	    if (useCamelCase && value && typeof value === "object") {
	      value = toCamel(value);
	    }
	    if (path || value instanceof Array) {
	      let upData = __spreadValues$h({}, data || {});
	      let upPath = useCamelCase ? toCamelPath(path) : path;
	      set(upData, upPath || "", value);
	      data = upData;
	    } else if (value && typeof value === "object") {
	      data = data || {};
	      data = merge(data, value);
	    } else {
	      data = value;
	    }
	    this.values(details, { data });
	    try {
	      const cache = VALUES[model][id];
	      if (cache !== void 0) {
	        if (cache.data !== void 0) {
	          cache.data = JSON.parse(JSON.stringify(cache.data));
	        }
	        if (cache.record !== void 0) {
	          cache.record = JSON.parse(JSON.stringify(cache.record));
	        }
	      }
	    } catch (err) {
	    }
	  },
	  get(model, id) {
	    this.debug("cache.get", ...arguments);
	    const { data, recordTimer } = this.values({ model, id });
	    this.debug("cache.get:data+recordTimer", ...arguments);
	    if (recordTimer) {
	      return data;
	    }
	  },
	  setRecord(record, details) {
	    this.debug("cache.setRecord", ...arguments);
	    let { recordTimer, presets } = this.values(details);
	    if (recordTimer) {
	      clearTimeout(recordTimer);
	    }
	    recordTimer = setTimeout(() => {
	      this.values(details, { record: void 0, recordTimer: void 0 });
	    }, RECORD_TIMEOUT);
	    this.values(details, {
	      record: record !== void 0 ? record : null,
	      recordTimer
	    });
	    if (presets) {
	      for (let preset of presets) {
	        this.set(preset);
	      }
	      this.values(details, { presets: void 0 });
	    }
	    const result = this.get(details.model, details.id);
	    return result !== void 0 ? result : record;
	  },
	  async getFetch(model, id, fetch) {
	    if (this.options.enabled) {
	      this.debug("cache.getFetch", ...arguments);
	      const value = this.get(model, id);
	      if (value !== void 0) {
	        return value;
	      }
	    }
	    const record = await fetch();
	    return this.setRecord(record, { model, id });
	  },
	  clear(model = void 0, id = void 0) {
	    this.debug("cache.clear", ...arguments);
	    if (model) {
	      if (id) {
	        set(VALUES, `${model}.${id}`, void 0);
	      } else {
	        set(VALUES, model, void 0);
	      }
	    } else {
	      VALUES = {};
	    }
	  }
	};

	function methods$a(request) {
	  const { get, list } = defaultMethods(request, "/attributes", ["list", "get"]);
	  return {
	    get: (id, ...args) => {
	      return cacheApi.getFetch("attributes", id, () => get(id, ...args));
	    },
	    list
	  };
	}

	var __defProp$g = Object.defineProperty;
	var __defProps$a = Object.defineProperties;
	var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
	var __hasOwnProp$g = Object.prototype.hasOwnProperty;
	var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$g = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$g.call(b, prop))
	      __defNormalProp$g(a, prop, b[prop]);
	  if (__getOwnPropSymbols$g)
	    for (var prop of __getOwnPropSymbols$g(b)) {
	      if (__propIsEnum$g.call(b, prop))
	        __defNormalProp$g(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
	let OPTIONS;
	function methods$9(request, opt) {
	  OPTIONS = opt;
	  const { get: get2, list } = defaultMethods(request, "/products", ["list", "get"]);
	  return {
	    get: (id, ...args) => {
	      return cacheApi.getFetch("products", id, () => get2(id, ...args));
	    },
	    list,
	    variation: calculateVariation,
	    categories: getCategories,
	    attributes: getAttributes,
	    priceRange: getPriceRange,
	    filters: getFilters,
	    filterableAttributeFilters: (products, options) => getFilterableAttributeFilters(request, products, options)
	  };
	}
	function getProductOptionIndex(product, filter = void 0) {
	  if (!product.options) {
	    return {};
	  }
	  const productOptions = filter ? product.options.filter(filter) : product.options;
	  return reduce(
	    productOptions,
	    (acc, op) => {
	      const values = reduce(
	        op.values,
	        (acc2, val) => __spreadProps$a(__spreadValues$g({}, acc2), {
	          [val.id]: __spreadProps$a(__spreadValues$g({}, val), { id: val.id }),
	          [val.name]: __spreadProps$a(__spreadValues$g({}, val), { id: val.id })
	        }),
	        {}
	      );
	      return __spreadProps$a(__spreadValues$g({}, acc), {
	        [op.id]: __spreadProps$a(__spreadValues$g({}, op), { values }),
	        [op.name]: __spreadProps$a(__spreadValues$g({}, op), { values })
	      });
	    },
	    {}
	  );
	}
	function cleanProductOptions(options) {
	  let result = options || [];
	  if (options && typeof options === "object" && !(options instanceof Array)) {
	    result = [];
	    for (const key in options) {
	      result.push({
	        id: key,
	        value: options[key]
	      });
	    }
	  }
	  if (result instanceof Array) {
	    return result.map((op) => ({
	      id: op.id || op.name,
	      value: op.value
	    }));
	  }
	  return result;
	}
	function findVariantWithOptionValueIds(product, ids) {
	  if (ids.length > 0) {
	    const variants = product.variants && product.variants.results;
	    if (variants.length > 0) {
	      for (const variant of variants) {
	        const variantObj = toSnake(variant);
	        const matched = isEqual(variantObj.option_value_ids.sort(), ids.sort());
	        if (matched) {
	          return variant;
	        }
	      }
	    }
	  }
	  return null;
	}
	function calculateVariation(input, options, purchaseOption) {
	  const product = OPTIONS.useCamelCase ? toSnake(input) : input;
	  const purchaseOp = findPurchaseOption(product, purchaseOption);
	  const variation = __spreadProps$a(__spreadValues$g({}, product), {
	    price: typeof purchaseOp.price !== "number" ? null : purchaseOp.price,
	    sale_price: purchaseOp.sale_price,
	    orig_price: purchaseOp.orig_price,
	    stock_status: product.stock_status
	  });
	  let optionPrice = 0;
	  const variantOptionValueIds = [];
	  const cleanOptions = cleanProductOptions(options);
	  const index = getProductOptionIndex(product);
	  for (const option of cleanOptions) {
	    if (index[option.id] && index[option.id].values[option.value]) {
	      if (index[option.id].variant) {
	        variantOptionValueIds.push(index[option.id].values[option.value].id);
	      } else {
	        optionPrice += index[option.id].values[option.value].price || 0;
	      }
	    }
	  }
	  if (variantOptionValueIds.length > 0) {
	    const variant = findVariantWithOptionValueIds(
	      product,
	      variantOptionValueIds
	    );
	    if (variant) {
	      let variantPurchaseOp = purchaseOp;
	      try {
	        variantPurchaseOp = findPurchaseOption(variant, purchaseOption);
	      } catch (err) {
	      }
	      variation.variant_id = variant.id;
	      variation.price = variantPurchaseOp.price || 0;
	      variation.sale_price = variantPurchaseOp.sale_price || purchaseOp.sale_price;
	      variation.orig_price = variantPurchaseOp.orig_price || purchaseOp.orig_price;
	      variation.stock_status = variant.stock_status;
	      variation.stock_level = variant.stock_level || 0;
	      variation.images = (variant.images && variant.images.length ? variant.images : product.images) || [];
	    }
	  }
	  if (optionPrice > 0) {
	    variation.price += optionPrice;
	    if (variation.sale_price) {
	      variation.sale_price += optionPrice;
	    }
	    if (variation.orig_price) {
	      variation.orig_price += optionPrice;
	    }
	  }
	  if (variation.sale_price === void 0) {
	    delete variation.sale_price;
	  }
	  if (variation.orig_price === void 0) {
	    delete variation.orig_price;
	  }
	  return OPTIONS.useCamelCase ? toCamel(variation) : variation;
	}
	function findPurchaseOption(product, purchaseOption) {
	  const plan = get(purchaseOption, "plan_id", get(purchaseOption, "plan"));
	  const type = get(
	    purchaseOption,
	    "type",
	    typeof purchaseOption === "string" ? purchaseOption : plan !== void 0 ? "subscription" : "standard"
	  );
	  let option = get(product, `purchase_options.${type}`);
	  if (!option && type !== "standard") {
	    throw new Error(
	      `Product purchase option '${type}' not found or not active`
	    );
	  }
	  if (option) {
	    if (option.plans) {
	      if (plan !== void 0) {
	        option = find(option.plans, { id: plan });
	        if (!option) {
	          throw new Error(
	            `Subscription purchase plan '${plan}' not found or not active`
	          );
	        }
	      } else {
	        option = option.plans[0];
	      }
	    }
	    return __spreadProps$a(__spreadValues$g({}, option), {
	      price: typeof option.price === "number" ? option.price : product.price,
	      sale_price: typeof option.sale_price === "number" ? option.sale_price : product.sale_price,
	      orig_price: typeof option.orig_price === "number" ? option.orig_price : product.orig_price
	    });
	  }
	  return {
	    type: "standard",
	    price: product.price,
	    sale_price: product.sale_price,
	    orig_price: product.orig_price
	  };
	}
	async function getFilterableAttributeFilters(request, products, options) {
	  const { results: filterableAttributes } = await methods$a(
	    request).list({
	    filterable: true
	  });
	  return getFilters(products, __spreadProps$a(__spreadValues$g({}, options), { filterableAttributes }));
	}
	function getFilters(products, options = {}) {
	  let attributes = (options.attributes || options.attributes === void 0) && getAttributes(products);
	  if (options.filterableAttributes) {
	    attributes = attributes.filter(
	      (productAttr) => options.filterableAttributes.find(
	        (filterableAttr) => productAttr.id === filterableAttr.id
	      )
	    );
	  }
	  const categories = (options.categories || options.categories === void 0) && getCategories(products);
	  const priceRange = (options.price || options.price === void 0) && getPriceRange(products);
	  let filters = [];
	  if (priceRange) {
	    filters.push({
	      id: "price",
	      label: "Price",
	      type: "range",
	      options: [
	        {
	          value: priceRange.min,
	          label: priceRange.min
	        },
	        {
	          value: priceRange.max,
	          label: priceRange.max
	        }
	      ],
	      interval: priceRange.interval
	    });
	  }
	  if (categories && categories.length > 0) {
	    filters.push({
	      id: "category",
	      label: "Category",
	      type: "select",
	      options: categories.map((category) => ({
	        value: category.slug,
	        label: category.name
	      }))
	    });
	  }
	  if (attributes && attributes.length > 0) {
	    filters = [
	      ...filters,
	      ...reduce(
	        attributes,
	        (acc, attr) => [
	          ...acc,
	          ...attr.id !== "category" && attr.id !== "price" && attr.values instanceof Array && attr.values.length > 0 ? [
	            {
	              id: attr.id,
	              label: attr.name,
	              type: "select",
	              options: attr.values.map((value) => ({
	                value,
	                label: value
	              }))
	            }
	          ] : []
	        ],
	        []
	      )
	    ];
	  }
	  return filters;
	}
	function getCategories(products) {
	  const categories = [];
	  const collection = products && products.results || (products.id ? [products] : products);
	  if (collection instanceof Array) {
	    for (let product of collection) {
	      if (product.categories) {
	        for (let category of product.categories) {
	          if (!category)
	            continue;
	          let ex = find(categories, { id: category.id });
	          if (!ex) {
	            categories.push(category);
	          }
	        }
	      }
	    }
	  }
	  return categories;
	}
	function getAttributes(products) {
	  const attributes = [];
	  const collection = products && products.results || (products.id ? [products] : products);
	  if (collection instanceof Array) {
	    for (let product of collection) {
	      if (product.attributes) {
	        for (let id in product.attributes) {
	          if (!product.attributes[id])
	            continue;
	          const value = product.attributes[id].value;
	          let attr = find(attributes, { id: snakeCase(id) });
	          if (attr) {
	            attr.values = uniq([
	              ...attr.values,
	              ...value instanceof Array ? value : [value]
	            ]);
	          } else {
	            attributes.push(__spreadProps$a(__spreadValues$g({}, product.attributes[id]), {
	              value: void 0,
	              values: [...value instanceof Array ? value : [value]]
	            }));
	          }
	        }
	      }
	    }
	  }
	  return attributes;
	}
	function getPriceRange(products) {
	  let min;
	  let max;
	  let interval;
	  const collection = products && products.results || (products.id ? [products] : products);
	  if (collection instanceof Array) {
	    for (let product of collection) {
	      if (max === void 0 || product.price > max) {
	        max = Math.ceil(product.price);
	      }
	      if (min === void 0 || product.price < min) {
	        min = Math.floor(product.price);
	      }
	    }
	  }
	  if (min === max) {
	    return null;
	  }
	  interval = Math.ceil((max - min) / 10) || 1;
	  if (interval > 1e3) {
	    interval = 1e3;
	  } else if (interval > 100) {
	    interval = 100;
	  } else if (interval > 10) {
	    interval = 10;
	  }
	  if (max % interval > 0) {
	    max = interval + max - max % interval;
	  }
	  if (min % interval > 0) {
	    min = min - min % interval;
	  }
	  while ((max - min) / interval % 1 > 0) {
	    max++;
	  }
	  return {
	    min,
	    max,
	    interval
	  };
	}

	var __defProp$f = Object.defineProperty;
	var __defProps$9 = Object.defineProperties;
	var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
	var __hasOwnProp$f = Object.prototype.hasOwnProperty;
	var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$f = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$f.call(b, prop))
	      __defNormalProp$f(a, prop, b[prop]);
	  if (__getOwnPropSymbols$f)
	    for (var prop of __getOwnPropSymbols$f(b)) {
	      if (__propIsEnum$f.call(b, prop))
	        __defNormalProp$f(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
	function methods$8(request, options) {
	  return {
	    state: null,
	    order: null,
	    settings: null,
	    requested: false,
	    pendingRequests: [],
	    cacheClear: null,
	    async requestStateChange(method, url, id, data) {
	      return this.requestStateSync(async () => {
	        const result = await request(method, url, id, data);
	        if (result && result.errors) {
	          return result;
	        }
	        this.state = result;
	        return result;
	      });
	    },
	    async requestStateSync(handler) {
	      if (this.state) {
	        return await handler();
	      } else if (this.requested) {
	        return new Promise((resolve) => {
	          this.pendingRequests.push({ handler, resolve });
	        });
	      }
	      this.requested = true;
	      const result = await handler();
	      this.requested = false;
	      while (this.pendingRequests.length > 0) {
	        const { handler: handler2, resolve } = this.pendingRequests.shift();
	        resolve(handler2());
	      }
	      return result;
	    },
	    get() {
	      if (options.getCart) {
	        return options.getCart();
	      }
	      let data;
	      if (this.cacheClear) {
	        this.cacheClear = null;
	        data = { $cache: false };
	      }
	      return this.requestStateChange("get", "/cart", void 0, data);
	    },
	    clearCache() {
	      this.cacheClear = true;
	    },
	    getItemData(item, data = {}) {
	      let result = cloneDeep(item);
	      if (typeof item === "string") {
	        result = __spreadProps$9(__spreadValues$f({}, data || {}), {
	          product_id: item
	        });
	      }
	      if (result && result.options) {
	        result.options = cleanProductOptions(result.options);
	      }
	      return result;
	    },
	    addItem(item, data) {
	      return this.requestStateChange(
	        "post",
	        "/cart/items",
	        this.getItemData(item, data)
	      );
	    },
	    updateItem(id, item) {
	      return this.requestStateChange(
	        "put",
	        `/cart/items/${id}`,
	        this.getItemData(item)
	      );
	    },
	    setItems(input) {
	      let items = input;
	      if (items && items.map) {
	        items = items.map(this.getItemData);
	      }
	      return this.requestStateChange("put", "/cart/items", items);
	    },
	    removeItem(id) {
	      return this.requestStateChange("delete", `/cart/items/${id}`);
	    },
	    recover(checkoutId) {
	      return this.requestStateChange("put", `/cart/recover/${checkoutId}`);
	    },
	    update(input) {
	      let data = input;
	      if (data.items && data.items.map) {
	        data = __spreadProps$9(__spreadValues$f({}, data), {
	          items: data.items.map(this.getItemData)
	        });
	      }
	      if (options.updateCart) {
	        return options.updateCart(input);
	      }
	      return this.requestStateChange("put", `/cart`, data);
	    },
	    applyCoupon(code) {
	      return this.requestStateChange("put", "/cart/coupon", { code });
	    },
	    removeCoupon() {
	      return this.requestStateChange("delete", "/cart/coupon");
	    },
	    applyGiftcard(code) {
	      return this.requestStateChange("post", "/cart/giftcards", { code });
	    },
	    removeGiftcard(id) {
	      return this.requestStateChange("delete", `/cart/giftcards/${id}`);
	    },
	    async getShippingRates() {
	      await this.requestStateChange("get", "/cart/shipment-rating");
	      return this.state[options.useCamelCase ? "shipmentRating" : "shipment_rating"];
	    },
	    async submitOrder() {
	      const result = await request("post", "/cart/order");
	      if (result.errors) {
	        return result;
	      }
	      this.state = null;
	      this.order = result;
	      return result;
	    },
	    async getOrder(checkoutId = void 0) {
	      let result;
	      if (checkoutId) {
	        result = await request("get", `/cart/order`, {
	          checkout_id: checkoutId
	        });
	      } else {
	        result = await request("get", `/cart/order`);
	      }
	      this.order = result;
	      return result;
	    },
	    async getSettings() {
	      this.settings = await request("get", "/cart/settings");
	      return this.settings;
	    }
	  };
	}

	function methods$7(request) {
	  return {
	    state: null,
	    async requestStateChange(method, url, id, data) {
	      const result = await request(method, url, id, data);
	      if (result && result.errors) {
	        return result;
	      }
	      return this.state = result;
	    },
	    get(query) {
	      return this.requestStateChange("get", "/account", query);
	    },
	    create(data) {
	      return this.requestStateChange("post", "/account", data);
	    },
	    update(data) {
	      return this.requestStateChange("put", "/account", data);
	    },
	    login(email, password) {
	      if (password && password.password_token) {
	        return this.requestStateChange("post", "/account/login", {
	          email,
	          password_token: password.password_token
	        });
	      }
	      return this.requestStateChange("post", "/account/login", {
	        email,
	        password
	      });
	    },
	    logout() {
	      this.state = null;
	      return request("post", "/account/logout");
	    },
	    recover(data) {
	      return request("post", "/account/recover", data);
	    },
	    listAddresses(query) {
	      return request("get", "/account/addresses", query);
	    },
	    createAddress(data) {
	      return request("post", "/account/addresses", data);
	    },
	    updateAddress(id, data) {
	      return request("put", `/account/addresses/${id}`, data);
	    },
	    deleteAddress(id) {
	      return request("delete", `/account/addresses/${id}`);
	    },
	    listCards(query) {
	      return request("get", "/account/cards", query);
	    },
	    createCard(data) {
	      return request("post", "/account/cards", data);
	    },
	    updateCard(id, data) {
	      return request("put", `/account/cards/${id}`, data);
	    },
	    deleteCard(id) {
	      return request("delete", `/account/cards/${id}`);
	    },
	    listOrders(query) {
	      return request("get", `/account/orders`, query);
	    },
	    getOrder(id) {
	      return request("get", `/account/orders/${id}`);
	    },
	    getAddresses(query) {
	      return request("get", "/account/addresses", query);
	    },
	    getCards(query) {
	      return request("get", "/account/cards", query);
	    },
	    getOrders(query) {
	      return request("get", `/account/orders`, query);
	    }
	  };
	}

	function methods$6(request) {
	  const { get, list } = defaultMethods(request, "/categories", ["list", "get"]);
	  return {
	    get: (id, ...args) => {
	      return cacheApi.getFetch("categories", id, () => get(id, ...args));
	    },
	    list
	  };
	}

	function methods$5(request) {
	  const { get, list } = defaultMethods(request, "/subscriptions", [
	    "list",
	    "get"
	  ]);
	  return {
	    get: (id, ...args) => {
	      return cacheApi.getFetch("subscriptions", id, () => get(id, ...args));
	    },
	    list,
	    getCleanData(data) {
	      if (data && data.options) {
	        data.options = cleanProductOptions(data.options);
	      }
	      if (data.items && data.items.map) {
	        data.items = data.items.map((item) => {
	          if (item.options) {
	            item.options = cleanProductOptions(item.options);
	          }
	          return item;
	        });
	      }
	      return data;
	    },
	    create(data) {
	      return request("post", "/subscriptions", this.getCleanData(data));
	    },
	    update(id, data) {
	      return request("put", `/subscriptions/${id}`, this.getCleanData(data));
	    },
	    addItem(id, item) {
	      return request(
	        "post",
	        `/subscriptions/${id}/items`,
	        this.getCleanData(item)
	      );
	    },
	    setItems(id, items) {
	      if (items && items.map) {
	        items = items.map(this.getCleanData);
	      }
	      return request("put", `/subscriptions/${id}/items`, items);
	    },
	    updateItem(id, itemId, item) {
	      return request(
	        "put",
	        `/subscriptions/${id}/items/${itemId}`,
	        this.getCleanData(item)
	      );
	    },
	    removeItem(id, itemId) {
	      return request("delete", `/subscriptions/${id}/items/${itemId}`);
	    }
	  };
	}

	function methods$4(request) {
	  const { get, list } = defaultMethods(request, "/invoices", ["list", "get"]);
	  return {
	    get: (id, ...args) => {
	      return cacheApi.getFetch("invoices", id, () => get(id, ...args));
	    },
	    list
	  };
	}

	var __defProp$e = Object.defineProperty;
	var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
	var __hasOwnProp$e = Object.prototype.hasOwnProperty;
	var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$e = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$e.call(b, prop))
	      __defNormalProp$e(a, prop, b[prop]);
	  if (__getOwnPropSymbols$e)
	    for (var prop of __getOwnPropSymbols$e(b)) {
	      if (__propIsEnum$e.call(b, prop))
	        __defNormalProp$e(a, prop, b[prop]);
	    }
	  return a;
	};
	function methods$3(request, opt) {
	  return {
	    get: (type, id, query) => {
	      return cacheApi.getFetch(
	        `content_${type}`,
	        id,
	        () => request("get", `/content/${type}`, id, __spreadValues$e({
	          $preview: opt.previewContent
	        }, query || {}))
	      );
	    },
	    list: (type, query) => request("get", `/content/${type}`, void 0, query)
	  };
	}

	var __defProp$d = Object.defineProperty;
	var __defProps$8 = Object.defineProperties;
	var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
	var __hasOwnProp$d = Object.prototype.hasOwnProperty;
	var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$d = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$d.call(b, prop))
	      __defNormalProp$d(a, prop, b[prop]);
	  if (__getOwnPropSymbols$d)
	    for (var prop of __getOwnPropSymbols$d(b)) {
	      if (__propIsEnum$d.call(b, prop))
	        __defNormalProp$d(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
	function methods$2(request, opt) {
	  return {
	    state: null,
	    menuState: null,
	    paymentState: null,
	    subscriptionState: null,
	    sessionState: null,
	    localizedState: {},
	    refresh() {
	      this.state = null;
	      this.menuState = null;
	      this.paymentState = null;
	      this.subscriptionState = null;
	      this.sessionState = null;
	      this.localizedState = {};
	      return this.get();
	    },
	    getState(uri, stateName, { id = void 0, def = void 0, refresh = false } = {}) {
	      if (!this[stateName] || refresh) {
	        this[stateName] = request("get", uri);
	      }
	      if (this[stateName] && typeof this[stateName].then === "function") {
	        return this[stateName].then((state) => {
	          this[stateName] = state;
	          return this.getLocalizedState(stateName, id, def);
	        });
	      }
	      return this.getLocalizedState(stateName, id, def);
	    },
	    getLocalizedState(stateName, id, def) {
	      const locale = this.getCurrentLocale();
	      const ls = this.localizedState;
	      if (ls.code !== locale) {
	        ls.code = locale;
	        delete ls[locale];
	      }
	      if (!ls[locale]) {
	        ls[locale] = {};
	      }
	      if (!ls[locale][stateName]) {
	        ls[locale][stateName] = this.decodeLocale(this[stateName]);
	      }
	      return id ? get(ls[locale][stateName], id, def) : ls[locale][stateName];
	    },
	    findState(uri, stateName, { where = void 0, def = void 0 } = {}) {
	      const state = this.getState(uri, stateName);
	      if (state && typeof state.then === "function") {
	        return state.then((state2) => find(state2, where) || def);
	      }
	      return find(state, where) || def;
	    },
	    get(id = void 0, def = void 0) {
	      return this.getState("/settings", "state", { id, def });
	    },
	    getCurrentLocale() {
	      return opt.api.locale.selected();
	    },
	    getStoreLocale() {
	      return get(this.state, "store.locale");
	    },
	    getStoreLocales() {
	      return get(this.state, "store.locales");
	    },
	    set({ model, path, value }) {
	      const locale = this.getCurrentLocale();
	      const stateName = model ? `${model.replace(/s$/, "")}State` : "state";
	      const { useCamelCase } = opt;
	      let mergeData = {};
	      if (path)
	        set(mergeData, path, value);
	      else
	        mergeData = value;
	      if (useCamelCase) {
	        mergeData = toCamel(mergeData);
	      }
	      this[stateName] = merge(this[stateName] || {}, mergeData);
	      if (this.localizedState[locale]) {
	        this.localizedState[locale][stateName] = this.decodeLocale(
	          this[stateName]
	        );
	      }
	    },
	    menus(id = void 0, def = void 0) {
	      return this.findState("/settings/menus", "menuState", {
	        where: { id },
	        def
	      });
	    },
	    payments(id = void 0, def = void 0) {
	      return this.getState("/settings/payments", "paymentState", { id, def });
	    },
	    subscriptions(id = void 0, def = void 0) {
	      return this.getState("/settings/subscriptions", "subscriptionState", {
	        id,
	        def
	      });
	    },
	    session(id = void 0, def = void 0) {
	      return this.getState("/session", "sessionState", { id, def });
	    },
	    decodeLocale(values) {
	      const locale = this.getCurrentLocale();
	      if (!values || typeof values !== "object") {
	        return values;
	      }
	      let configs = this.getStoreLocales();
	      if (configs) {
	        configs = configs.reduce(
	          (acc, config) => __spreadProps$8(__spreadValues$d({}, acc), {
	            [config.code]: config
	          }),
	          {}
	        );
	      } else {
	        configs = {};
	      }
	      return decodeLocaleObjects(cloneDeep(values), locale, configs, opt);
	    },
	    async load() {
	      try {
	        const { settings, menus, payments, subscriptions, session } = await request("get", "/settings/all");
	        this.localizedState = {};
	        this.set({
	          value: settings
	        });
	        this.set({
	          model: "menus",
	          value: menus
	        });
	        this.set({
	          model: "payments",
	          value: payments
	        });
	        this.set({
	          model: "subscriptions",
	          value: subscriptions
	        });
	        this.set({
	          model: "session",
	          value: session
	        });
	      } catch (err) {
	        console.error(`Swell: unable to loading settings (${err})`);
	      }
	    }
	  };
	}
	function decodeLocaleObjects(values, locale, configs, opt) {
	  if (isObject(values)) {
	    const keys = Object.keys(values);
	    for (let key of keys) {
	      if (key === "$locale") {
	        decodeLocaleValue(locale, values, key, configs, opt);
	        delete values.$locale;
	      }
	      if (values[key] !== void 0) {
	        values[key] = decodeLocaleObjects(values[key], locale, configs, opt);
	      }
	    }
	  } else if (values instanceof Array) {
	    for (var i = 0; i < values.length; i++) {
	      values[i] = decodeLocaleObjects(values[i], locale, configs, opt);
	    }
	  }
	  return values;
	}
	function decodeLocaleValue(locale, values, key, configs, opt) {
	  if (!locale || !isObject(values[key])) {
	    return;
	  }
	  let returnLocaleKey;
	  let returnLocaleConfig;
	  const localeKeys = Object.keys(values[key]);
	  for (let localeKey of localeKeys) {
	    const shortKey = localeKey.replace(/\-.+$/, "");
	    const transformedLocale = opt.useCamelCase ? camelCase(locale) : locale;
	    if (localeKey === locale || localeKey === transformedLocale || shortKey === transformedLocale) {
	      returnLocaleKey = locale;
	      returnLocaleConfig = configs[locale];
	    }
	  }
	  if (!returnLocaleKey && isObject(configs)) {
	    const localeKeys2 = Object.keys(configs);
	    for (let localeKey of localeKeys2) {
	      const shortKey = localeKey.replace(/\-.+$/, "");
	      if (localeKey === locale || shortKey === locale) {
	        returnLocaleKey = localeKey;
	        returnLocaleConfig = configs[localeKey];
	      }
	    }
	  }
	  let fallbackKeys;
	  let fallbackValues = {};
	  if (returnLocaleConfig) {
	    let fallbackKey = returnLocaleConfig.fallback;
	    const origFallbackKey = fallbackKey;
	    while (fallbackKey) {
	      fallbackKeys = fallbackKeys || [];
	      fallbackKeys.push(fallbackKey);
	      fallbackValues = __spreadValues$d(__spreadValues$d({}, values[key][fallbackKey] || {}), fallbackValues);
	      fallbackKey = configs[fallbackKey] && configs[fallbackKey].fallback;
	      if (origFallbackKey === fallbackKey) {
	        break;
	      }
	    }
	  }
	  let localeValues = __spreadValues$d(__spreadValues$d({}, fallbackValues), values[key][returnLocaleKey] || {});
	  const valueKeys = Object.keys(localeValues);
	  for (let valueKey of valueKeys) {
	    const hasValue = localeValues[valueKey] !== null && localeValues[valueKey] !== "";
	    let shouldFallback = fallbackKeys && !hasValue;
	    if (shouldFallback) {
	      for (let fallbackKey of fallbackKeys) {
	        shouldFallback = !values[key][fallbackKey] || values[key][fallbackKey][valueKey] === null || values[key][fallbackKey][valueKey] === "";
	        if (shouldFallback) {
	          if (fallbackKey === "none") {
	            values[valueKey] = null;
	            break;
	          }
	          continue;
	        } else {
	          values[valueKey] = values[key][fallbackKey][valueKey];
	          break;
	        }
	      }
	    } else {
	      if (hasValue) {
	        values[valueKey] = localeValues[valueKey];
	      }
	    }
	  }
	}

	const SCRIPT_HANDLERS = {
	  "stripe-js": loadStripe,
	  "paypal-sdk": loadPaypal,
	  "google-pay": loadGoogle,
	  "braintree-web": loadBraintree,
	  "braintree-paypal-sdk": loadBraintreePaypal,
	  "braintree-web-paypal-checkout": loadBraintreePaypalCheckout,
	  "braintree-google-payment": loadBraintreeGoogle,
	  "braintree-apple-payment": loadBraintreeApple,
	  "amazon-checkout": loadAmazonCheckout
	};
	async function loadStripe() {
	  if (!window.Stripe || window.Stripe.version !== 3) {
	    await loadScript("stripe-js", "https://js.stripe.com/v3/");
	  }
	  if (!window.Stripe) {
	    console.error("Warning: Stripe was not loaded");
	  }
	  if (window.Stripe.StripeV3) {
	    window.Stripe = window.Stripe.StripeV3;
	  }
	  if (window.Stripe.version !== 3) {
	    console.error("Warning: Stripe V3 was not loaded");
	  }
	}
	async function loadPaypal(params) {
	  if (!window.paypal) {
	    await loadScript(
	      "paypal-sdk",
	      `https://www.paypal.com/sdk/js?currency=${params.currency}&client-id=${params.client_id}&merchant-id=${params.merchant_id}&intent=authorize&commit=false`,
	      {
	        "data-partner-attribution-id": "SwellCommerce_SP"
	      }
	    );
	  }
	  if (!window.paypal) {
	    console.error("Warning: PayPal was not loaded");
	  }
	}
	async function loadGoogle() {
	  if (!window.google) {
	    await loadScript("google-pay", "https://pay.google.com/gp/p/js/pay.js");
	  }
	  if (!window.google) {
	    console.error("Warning: Google was not loaded");
	  }
	}
	async function loadBraintree() {
	  if (!window.braintree) {
	    await loadScript(
	      "braintree-web",
	      "https://js.braintreegateway.com/web/3.73.1/js/client.min.js"
	    );
	  }
	  if (!window.braintree) {
	    console.error("Warning: Braintree was not loaded");
	  }
	}
	async function loadBraintreePaypal(params) {
	  if (!window.paypal) {
	    await loadScript(
	      "braintree-paypal-sdk",
	      `https://www.paypal.com/sdk/js?client-id=${params.client_id}&merchant-id=${params.merchant_id}&vault=true`
	    );
	  }
	  if (!window.paypal) {
	    console.error("Warning: Braintree PayPal was not loaded");
	  }
	}
	async function loadBraintreePaypalCheckout() {
	  if (window.braintree && !window.braintree.paypalCheckout) {
	    await loadScript(
	      "braintree-web-paypal-checkout",
	      "https://js.braintreegateway.com/web/3.73.1/js/paypal-checkout.min.js"
	    );
	  }
	  if (window.braintree && !window.braintree.paypalCheckout) {
	    console.error("Warning: Braintree PayPal Checkout was not loaded");
	  }
	}
	async function loadBraintreeGoogle() {
	  if (window.braintree && !window.braintree.googlePayment) {
	    await loadScript(
	      "braintree-google-payment",
	      "https://js.braintreegateway.com/web/3.73.1/js/google-payment.min.js"
	    );
	  }
	  if (window.braintree && !window.braintree.googlePayment) {
	    console.error("Warning: Braintree Google Payment was not loaded");
	  }
	}
	async function loadBraintreeApple() {
	  if (window.braintree && !window.braintree.applePay) {
	    await loadScript(
	      "braintree-apple-payment",
	      "https://js.braintreegateway.com/web/3.73.1/js/apple-pay.min.js"
	    );
	  }
	  if (window.braintree && !window.braintree.applePay) {
	    console.error("Warning: Braintree Apple Payment was not loaded");
	  }
	}
	async function loadAmazonCheckout() {
	  if (!window.amazon) {
	    await loadScript(
	      "amazon-checkout",
	      "https://static-na.payments-amazon.com/checkout.js"
	    );
	  }
	  if (!window.amazon) {
	    console.error("Warning: Amazon Checkout was not loaded");
	  }
	}
	async function loadScripts(scripts) {
	  if (!scripts) {
	    return;
	  }
	  for (const script of scripts) {
	    let scriptId = script;
	    let scriptParams;
	    if (isObject(script)) {
	      scriptId = script.id;
	      scriptParams = script.params;
	    }
	    const scriptHandler = SCRIPT_HANDLERS[scriptId];
	    if (!isFunction(scriptHandler)) {
	      console.error(`Unknown script ID: ${scriptId}`);
	      continue;
	    }
	    await scriptHandler(scriptParams);
	  }
	  await new Promise((resolve) => setTimeout(resolve, 1e3));
	}

	var __defProp$c = Object.defineProperty;
	var __defProps$7 = Object.defineProperties;
	var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
	var __hasOwnProp$c = Object.prototype.hasOwnProperty;
	var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$c = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$c.call(b, prop))
	      __defNormalProp$c(a, prop, b[prop]);
	  if (__getOwnPropSymbols$c)
	    for (var prop of __getOwnPropSymbols$c(b)) {
	      if (__propIsEnum$c.call(b, prop))
	        __defNormalProp$c(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
	class Payment {
	  constructor(request, options, params, method) {
	    this.request = request;
	    this.options = options;
	    this.params = params;
	    this.method = method;
	  }
	  async loadScripts(scripts) {
	    await this._populateScriptsParams(scripts);
	    await loadScripts(scripts);
	  }
	  async getCart() {
	    const cart = await methods$8(this.request, this.options).get();
	    if (!cart) {
	      throw new Error("Cart not found");
	    }
	    return this._adjustCart(cart);
	  }
	  async updateCart(data) {
	    const updateData = cloneDeep(data);
	    if (data.account) {
	      const cart = await this.getCart();
	      const shouldUpdateAccount = cart.guest && !get(cart, "account.email");
	      if (!shouldUpdateAccount) {
	        delete updateData.account;
	      }
	    }
	    const updatedCart = await methods$8(this.request, this.options).update(
	      updateData
	    );
	    return this._adjustCart(updatedCart);
	  }
	  async getSettings() {
	    return methods$2(this.request, this.options).get();
	  }
	  async createIntent(data) {
	    return this._vaultRequest("post", "/intent", data);
	  }
	  async updateIntent(data) {
	    return this._vaultRequest("put", "/intent", data);
	  }
	  async authorizeGateway(data) {
	    return this._vaultRequest("post", "/authorization", data);
	  }
	  onSuccess(data) {
	    const successHandler = get(this.params, "onSuccess");
	    if (isFunction(successHandler)) {
	      return successHandler(data);
	    }
	  }
	  onCancel() {
	    const cancelHandler = get(this.params, "onCancel");
	    if (isFunction(cancelHandler)) {
	      return cancelHandler();
	    }
	  }
	  onError(error) {
	    const errorHandler = get(this.params, "onError");
	    if (isFunction(errorHandler)) {
	      return errorHandler(error);
	    }
	    console.error(error.message);
	  }
	  async _adjustCart(cart) {
	    return this._ensureCartSettings(cart).then(toSnake);
	  }
	  async _ensureCartSettings(cart) {
	    if (cart.settings) {
	      return cart;
	    }
	    const settings = await this.getSettings();
	    return __spreadProps$7(__spreadValues$c({}, cart), { settings: __spreadValues$c({}, settings.store) });
	  }
	  async _vaultRequest(method, url, data) {
	    const response = await vaultRequest(method, url, data);
	    if (response.errors) {
	      const param = Object.keys(response.errors)[0];
	      const err = new Error(response.errors[param].message || "Unknown error");
	      err.code = "vault_error";
	      err.status = 402;
	      err.param = param;
	      throw err;
	    }
	    return response;
	  }
	  async _populateScriptsParams(scripts = []) {
	    for (const script of scripts) {
	      await this._populateScriptWithCartParams(script);
	    }
	  }
	  async _populateScriptWithCartParams(script) {
	    const cartParams = get(script, "params.cart");
	    if (!cartParams) {
	      return;
	    }
	    const cart = await this.getCart();
	    script.params = __spreadValues$c(__spreadValues$c({}, script.params), pick(cart, cartParams));
	    delete script.params.cart;
	  }
	}

	var __defProp$b = Object.defineProperty;
	var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
	var __hasOwnProp$b = Object.prototype.hasOwnProperty;
	var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$b = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$b.call(b, prop))
	      __defNormalProp$b(a, prop, b[prop]);
	  if (__getOwnPropSymbols$b)
	    for (var prop of __getOwnPropSymbols$b(b)) {
	      if (__propIsEnum$b.call(b, prop))
	        __defNormalProp$b(a, prop, b[prop]);
	    }
	  return a;
	};
	const MINIMUM_CHARGE_AMOUNT = {
	  USD: 0.5,
	  AED: 2,
	  AUD: 0.5,
	  BGN: 1,
	  BRL: 0.5,
	  CAD: 0.5,
	  CHF: 0.5,
	  CZK: 15,
	  DKK: 2.5,
	  EUR: 0.5,
	  GBP: 0.3,
	  HKD: 4,
	  HRK: 0.5,
	  HUF: 175,
	  INR: 0.5,
	  JPY: 50,
	  MXN: 10,
	  MYR: 2,
	  NOK: 3,
	  NZD: 0.5,
	  PLN: 2,
	  RON: 2,
	  SEK: 3,
	  SGD: 0.5,
	  THB: 10
	};
	const addressFieldsMap$1 = {
	  city: "city",
	  country: "country",
	  line1: "address1",
	  line2: "address2",
	  postal_code: "zip",
	  state: "state"
	};
	const billingFieldsMap = {
	  name: "name",
	  phone: "phone"
	};
	function mapValues(fieldsMap, data) {
	  const result = {};
	  for (const [destinationKey, sourceKey] of Object.entries(fieldsMap)) {
	    const value = data[sourceKey];
	    if (value) {
	      result[destinationKey] = value;
	    }
	  }
	  return result;
	}
	function getBillingDetails(cart) {
	  const details = __spreadValues$b({}, mapValues(billingFieldsMap, cart.billing));
	  if (cart.account && cart.account.email) {
	    details.email = cart.account.email;
	  }
	  const address = mapValues(addressFieldsMap$1, cart.billing);
	  if (!isEmpty(address)) {
	    details.address = address;
	  }
	  return details;
	}
	function getKlarnaItems(cart) {
	  const currency = toLower(get(cart, "currency", "eur"));
	  const items = map(cart.items, (item) => ({
	    type: "sku",
	    description: item.product.name,
	    quantity: item.quantity,
	    currency,
	    amount: Math.round(toNumber(item.price_total - item.discount_total) * 100)
	  }));
	  const tax = get(cart, "tax_included_total");
	  if (tax) {
	    items.push({
	      type: "tax",
	      description: "Taxes",
	      currency,
	      amount: Math.round(toNumber(tax) * 100)
	    });
	  }
	  const shipping = get(cart, "shipping", {});
	  const shippingTotal = get(cart, "shipment_total", {});
	  if (shipping.price) {
	    items.push({
	      type: "shipping",
	      description: shipping.service_name,
	      currency,
	      amount: Math.round(toNumber(shippingTotal) * 100)
	    });
	  }
	  return items;
	}
	function setKlarnaBillingShipping(source, data) {
	  const shippingNameFieldsMap = {
	    shipping_first_name: "first_name",
	    shipping_last_name: "last_name"
	  };
	  const shippingFieldsMap = {
	    phone: "phone"
	  };
	  const billingNameFieldsMap = {
	    first_name: "first_name",
	    last_name: "last_name"
	  };
	  const billingFieldsMap2 = {
	    email: "email"
	  };
	  const fillValues = (fieldsMap, data2) => reduce(
	    fieldsMap,
	    (acc, srcKey, destKey) => {
	      const value = data2[srcKey];
	      if (value) {
	        acc[destKey] = value;
	      }
	      return acc;
	    },
	    {}
	  );
	  source.klarna = __spreadValues$b(__spreadValues$b({}, source.klarna), fillValues(shippingNameFieldsMap, data.shipping));
	  const shipping = fillValues(shippingFieldsMap, data.shipping);
	  const shippingAddress = fillValues(addressFieldsMap$1, data.shipping);
	  if (shipping || shippingAddress) {
	    source.source_order.shipping = __spreadValues$b(__spreadValues$b({}, shipping ? shipping : {}), shippingAddress ? { address: shippingAddress } : {});
	  }
	  source.klarna = __spreadValues$b(__spreadValues$b({}, source.klarna), fillValues(
	    billingNameFieldsMap,
	    data.billing || get(data, "account.billing") || data.shipping
	  ));
	  const billing = fillValues(billingFieldsMap2, data.account);
	  const billingAddress = fillValues(
	    addressFieldsMap$1,
	    data.billing || get(data, "account.billing") || data.shipping
	  );
	  if (billing || billingAddress) {
	    source.owner = __spreadValues$b(__spreadValues$b({}, billing ? billing : {}), billingAddress ? { address: billingAddress } : {});
	  }
	}
	function setBancontactOwner(source, data) {
	  const fillValues = (fieldsMap, data2) => reduce(
	    fieldsMap,
	    (acc, srcKey, destKey) => {
	      const value = data2[srcKey];
	      if (value) {
	        acc[destKey] = value;
	      }
	      return acc;
	    },
	    {}
	  );
	  const { account = {}, billing, shipping } = data;
	  const billingData = __spreadValues$b(__spreadValues$b(__spreadValues$b(__spreadValues$b({}, account.shipping), account.billing), shipping), billing);
	  const billingAddress = fillValues(addressFieldsMap$1, billingData);
	  source.owner = __spreadValues$b(__spreadValues$b({
	    email: account.email,
	    name: billingData.name || account.name
	  }, billingData.phone ? { phone: billingData.phone } : account.phone ? { phone: account.phone } : {}), !isEmpty(billingAddress) ? { address: billingAddress } : {});
	}
	function createElement(type, elements, params) {
	  const elementParams = params[type] || params;
	  const elementOptions = elementParams.options || {};
	  const element = elements.create(type, elementOptions);
	  elementParams.onChange && element.on("change", elementParams.onChange);
	  elementParams.onReady && element.on("ready", elementParams.onReady);
	  elementParams.onFocus && element.on("focus", elementParams.onFocus);
	  elementParams.onBlur && element.on("blur", elementParams.onBlur);
	  elementParams.onEscape && element.on("escape", elementParams.onEscape);
	  elementParams.onClick && element.on("click", elementParams.onClick);
	  element.mount(elementParams.elementId || `#${type}-element`);
	  return element;
	}
	async function createPaymentMethod(stripe, cardElement, cart) {
	  const billingDetails = getBillingDetails(cart);
	  const { paymentMethod, error } = await stripe.createPaymentMethod({
	    type: "card",
	    card: cardElement,
	    billing_details: billingDetails
	  });
	  return error ? { error } : {
	    token: paymentMethod.id,
	    last4: paymentMethod.card.last4,
	    exp_month: paymentMethod.card.exp_month,
	    exp_year: paymentMethod.card.exp_year,
	    brand: paymentMethod.card.brand,
	    address_check: paymentMethod.card.checks.address_line1_check,
	    cvc_check: paymentMethod.card.checks.cvc_check,
	    zip_check: paymentMethod.card.checks.address_zip_check
	  };
	}
	async function createIDealPaymentMethod(stripe, element, cart) {
	  const billingDetails = getBillingDetails(cart);
	  return await stripe.createPaymentMethod(__spreadValues$b({
	    type: "ideal",
	    ideal: element
	  }, billingDetails ? { billing_details: billingDetails } : {}));
	}
	async function createKlarnaSource(stripe, cart) {
	  const sourceObject = {
	    type: "klarna",
	    flow: "redirect",
	    amount: Math.round(get(cart, "grand_total", 0) * 100),
	    currency: toLower(get(cart, "currency", "eur")),
	    klarna: {
	      product: "payment",
	      purchase_country: get(cart, "settings.country", "DE")
	    },
	    source_order: {
	      items: getKlarnaItems(cart)
	    },
	    redirect: {
	      return_url: window.location.href
	    }
	  };
	  setKlarnaBillingShipping(sourceObject, cart);
	  return await stripe.createSource(sourceObject);
	}
	async function createBancontactSource(stripe, cart) {
	  const sourceObject = {
	    type: "bancontact",
	    amount: Math.round(get(cart, "grand_total", 0) * 100),
	    currency: toLower(get(cart, "currency", "eur")),
	    redirect: {
	      return_url: window.location.href
	    }
	  };
	  setBancontactOwner(sourceObject, cart);
	  return await stripe.createSource(sourceObject);
	}
	function stripeAmountByCurrency(currency, amount) {
	  const zeroDecimalCurrencies = [
	    "BIF",
	    "DJF",
	    "JPY",
	    "KRW",
	    "PYG",
	    "VND",
	    "XAF",
	    "XPF",
	    "CLP",
	    "GNF",
	    "KMF",
	    "MGA",
	    "RWF",
	    "VUV",
	    "XOF"
	  ];
	  if (zeroDecimalCurrencies.includes(currency.toUpperCase())) {
	    return amount;
	  } else {
	    return Math.round(amount * 100);
	  }
	}
	function isStripeChargeableAmount(amount, currency) {
	  const minAmount = MINIMUM_CHARGE_AMOUNT[currency];
	  return !minAmount || amount >= minAmount;
	}

	class PaymentMethodDisabledError extends Error {
	  constructor(method) {
	    const message = `${method} payments are disabled. See Payment settings in the Swell dashboard for details`;
	    super(message);
	  }
	}
	class UnsupportedPaymentMethodError extends Error {
	  constructor(method, gateway) {
	    let message = `Unsupported payment method: ${method}`;
	    if (gateway) {
	      message += ` (${gateway})`;
	    }
	    super(message);
	  }
	}
	class UnableAuthenticatePaymentMethodError extends Error {
	  constructor() {
	    const message = "We are unable to authenticate your payment method. Please choose a different payment method and try again";
	    super(message);
	  }
	}
	class LibraryNotLoadedError extends Error {
	  constructor(library) {
	    const message = `${library} was not loaded`;
	    super(message);
	  }
	}
	class MethodPropertyMissingError extends Error {
	  constructor(method, property) {
	    const message = `${method} ${property} is missing`;
	    super(message);
	  }
	}
	class DomElementNotFoundError extends Error {
	  constructor(elementId) {
	    const message = `DOM element with '${elementId}' ID not found`;
	    super(message);
	  }
	}

	var __defProp$a = Object.defineProperty;
	var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
	var __hasOwnProp$a = Object.prototype.hasOwnProperty;
	var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$a = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$a.call(b, prop))
	      __defNormalProp$a(a, prop, b[prop]);
	  if (__getOwnPropSymbols$a)
	    for (var prop of __getOwnPropSymbols$a(b)) {
	      if (__propIsEnum$a.call(b, prop))
	        __defNormalProp$a(a, prop, b[prop]);
	    }
	  return a;
	};
	class StripeCardPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.card);
	  }
	  get scripts() {
	    return ["stripe-js"];
	  }
	  get stripe() {
	    if (!StripeCardPayment.stripe) {
	      if (window.Stripe) {
	        this.stripe = window.Stripe(this.method.publishable_key);
	      }
	      if (!StripeCardPayment.stripe) {
	        throw new LibraryNotLoadedError("Stripe");
	      }
	    }
	    return StripeCardPayment.stripe;
	  }
	  set stripe(stripe) {
	    StripeCardPayment.stripe = stripe;
	  }
	  get stripeElement() {
	    return StripeCardPayment.stripeElement;
	  }
	  set stripeElement(stripeElement) {
	    StripeCardPayment.stripeElement = stripeElement;
	  }
	  async createElements() {
	    const elements = this.stripe.elements(this.params.config);
	    if (this.params.separateElements) {
	      this.stripeElement = createElement("cardNumber", elements, this.params);
	      createElement("cardExpiry", elements, this.params);
	      createElement("cardCvc", elements, this.params);
	    } else {
	      this.stripeElement = createElement("card", elements, this.params);
	    }
	  }
	  async tokenize() {
	    if (!this.stripeElement) {
	      throw new Error("Stripe payment element is not defined");
	    }
	    const cart = await this.getCart();
	    const paymentMethod = await createPaymentMethod(
	      this.stripe,
	      this.stripeElement,
	      cart
	    );
	    if (paymentMethod.error) {
	      throw new Error(paymentMethod.error.message);
	    }
	    if (!isStripeChargeableAmount(cart.capture_total, cart.currency)) {
	      await this.updateCart({
	        billing: {
	          method: "card",
	          card: paymentMethod
	        }
	      });
	      return this.onSuccess();
	    }
	    const intent = await this._createIntent(cart, paymentMethod);
	    await this.updateCart({
	      billing: {
	        method: "card",
	        card: paymentMethod,
	        intent: {
	          stripe: __spreadValues$a({
	            id: intent.id
	          }, Boolean(cart.auth_total) && {
	            auth_amount: cart.auth_total
	          })
	        }
	      }
	    });
	    this.onSuccess();
	  }
	  async authenticate(payment) {
	    const { transaction_id: id, card: { token } = {} } = payment;
	    const intent = await this.updateIntent({
	      gateway: "stripe",
	      intent: { id, payment_method: token }
	    });
	    if (intent.error) {
	      throw new Error(intent.error.message);
	    }
	    return this._confirmCardPayment(intent);
	  }
	  async _createIntent(cart, paymentMethod) {
	    const { account, currency, capture_total, auth_total } = cart;
	    const stripeCustomer = account && account.stripe_customer;
	    const stripeCurrency = (currency || "USD").toLowerCase();
	    const amount = stripeAmountByCurrency(currency, capture_total + auth_total);
	    const intent = await this.createIntent({
	      gateway: "stripe",
	      intent: __spreadValues$a({
	        amount,
	        currency: stripeCurrency,
	        payment_method: paymentMethod.token,
	        capture_method: "manual",
	        setup_future_usage: "off_session"
	      }, stripeCustomer ? { customer: stripeCustomer } : {})
	    });
	    if (!intent) {
	      throw new Error("Stripe payment intent is not defined");
	    }
	    if (!["requires_capture", "requires_confirmation"].includes(intent.status)) {
	      throw new Error(`Unsupported intent status: ${intent.status}`);
	    }
	    if (intent.status === "requires_confirmation") {
	      await this._confirmCardPayment(intent);
	    }
	    return intent;
	  }
	  async _confirmCardPayment(intent) {
	    const actionResult = await this.stripe.confirmCardPayment(
	      intent.client_secret
	    );
	    if (actionResult.error) {
	      throw new Error(actionResult.error.message);
	    }
	    return { status: actionResult.status };
	  }
	}

	var __defProp$9 = Object.defineProperty;
	var __defProps$6 = Object.defineProperties;
	var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
	var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
	var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$9 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$9.call(b, prop))
	      __defNormalProp$9(a, prop, b[prop]);
	  if (__getOwnPropSymbols$9)
	    for (var prop of __getOwnPropSymbols$9(b)) {
	      if (__propIsEnum$9.call(b, prop))
	        __defNormalProp$9(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
	class StripeIDealPayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    const method = __spreadProps$6(__spreadValues$9({}, methods.ideal), {
	      publishable_key: methods.card.publishable_key
	    });
	    super(request, options, params, method);
	  }
	  get scripts() {
	    return ["stripe-js"];
	  }
	  get stripe() {
	    if (!StripeIDealPayment.stripe) {
	      if (window.Stripe) {
	        this.stripe = window.Stripe(this.method.publishable_key);
	      }
	      if (!StripeIDealPayment.stripe) {
	        throw new LibraryNotLoadedError("Stripe");
	      }
	    }
	    return StripeIDealPayment.stripe;
	  }
	  set stripe(stripe) {
	    StripeIDealPayment.stripe = stripe;
	  }
	  get stripeElement() {
	    return StripeIDealPayment.stripeElement;
	  }
	  set stripeElement(stripeElement) {
	    StripeIDealPayment.stripeElement = stripeElement;
	  }
	  async createElements() {
	    const elements = this.stripe.elements(this.params.config);
	    this.stripeElement = createElement("idealBank", elements, this.params);
	  }
	  async tokenize() {
	    if (!this.stripeElement) {
	      throw new Error("Stripe payment element is not defined");
	    }
	    const cart = await this.getCart();
	    const { paymentMethod, error: paymentMethodError } = await createIDealPaymentMethod(this.stripe, this.stripeElement, cart);
	    if (paymentMethodError) {
	      throw new Error(paymentMethodError.message);
	    }
	    const intent = await this._createIntent(cart, paymentMethod);
	    await this.stripe.handleCardAction(intent.client_secret);
	  }
	  async _createIntent(cart, paymentMethod) {
	    const { currency, capture_total } = cart;
	    const stripeCurrency = (currency || "EUR").toLowerCase();
	    const amount = stripeAmountByCurrency(currency, capture_total);
	    const intent = await this.createIntent({
	      gateway: "stripe",
	      intent: {
	        amount,
	        currency: stripeCurrency,
	        payment_method: paymentMethod.id,
	        payment_method_types: "ideal",
	        confirmation_method: "manual",
	        confirm: true,
	        return_url: window.location.href
	      }
	    });
	    if (!intent) {
	      throw new Error("Stripe payment intent is not defined");
	    }
	    if (!["requires_action", "requires_source_action"].includes(intent.status)) {
	      throw new Error(`Unsupported intent status (${intent.status})`);
	    }
	    await this.updateCart({
	      billing: {
	        method: "ideal",
	        ideal: {
	          token: paymentMethod.id
	        },
	        intent: {
	          stripe: {
	            id: intent.id
	          }
	        }
	      }
	    });
	    return intent;
	  }
	}

	var __defProp$8 = Object.defineProperty;
	var __defProps$5 = Object.defineProperties;
	var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
	var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
	var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$8 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$8.call(b, prop))
	      __defNormalProp$8(a, prop, b[prop]);
	  if (__getOwnPropSymbols$8)
	    for (var prop of __getOwnPropSymbols$8(b)) {
	      if (__propIsEnum$8.call(b, prop))
	        __defNormalProp$8(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
	class StripeBancontactPayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    const method = __spreadProps$5(__spreadValues$8({}, methods.bancontact), {
	      publishable_key: methods.card.publishable_key
	    });
	    super(request, options, params, method);
	  }
	  get scripts() {
	    return ["stripe-js"];
	  }
	  get stripe() {
	    if (!StripeBancontactPayment.stripe) {
	      if (window.Stripe) {
	        this.stripe = window.Stripe(this.method.publishable_key);
	      }
	      if (!StripeBancontactPayment.stripe) {
	        throw new LibraryNotLoadedError("Stripe");
	      }
	    }
	    return StripeBancontactPayment.stripe;
	  }
	  set stripe(stripe) {
	    StripeBancontactPayment.stripe = stripe;
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const { source, error: sourceError } = await createBancontactSource(
	      this.stripe,
	      cart
	    );
	    if (sourceError) {
	      throw new Error(sourceError.message);
	    }
	    await this.updateCart({
	      billing: {
	        method: "bancontact"
	      }
	    });
	    window.location.replace(source.redirect.url);
	  }
	}

	var __defProp$7 = Object.defineProperty;
	var __defProps$4 = Object.defineProperties;
	var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
	var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
	var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$7 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$7.call(b, prop))
	      __defNormalProp$7(a, prop, b[prop]);
	  if (__getOwnPropSymbols$7)
	    for (var prop of __getOwnPropSymbols$7(b)) {
	      if (__propIsEnum$7.call(b, prop))
	        __defNormalProp$7(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
	class StripeKlarnaPayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    const method = __spreadProps$4(__spreadValues$7({}, methods.klarna), {
	      publishable_key: methods.card.publishable_key
	    });
	    super(request, options, params, method);
	  }
	  get scripts() {
	    return ["stripe-js"];
	  }
	  get stripe() {
	    if (!StripeKlarnaPayment.stripe) {
	      if (window.Stripe) {
	        this.stripe = window.Stripe(this.method.publishable_key);
	      }
	      if (!StripeKlarnaPayment.stripe) {
	        throw new LibraryNotLoadedError("Stripe");
	      }
	    }
	    return StripeKlarnaPayment.stripe;
	  }
	  set stripe(stripe) {
	    StripeKlarnaPayment.stripe = stripe;
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const { source, error: sourceError } = await createKlarnaSource(
	      this.stripe,
	      cart
	    );
	    if (sourceError) {
	      throw new Error(sourceError.message);
	    }
	    await this.updateCart({
	      billing: {
	        method: "klarna"
	      }
	    });
	    window.location.replace(source.redirect.url);
	  }
	}

	var __defProp$6 = Object.defineProperty;
	var __defProps$3 = Object.defineProperties;
	var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
	var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
	var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$6 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$6.call(b, prop))
	      __defNormalProp$6(a, prop, b[prop]);
	  if (__getOwnPropSymbols$6)
	    for (var prop of __getOwnPropSymbols$6(b)) {
	      if (__propIsEnum$6.call(b, prop))
	        __defNormalProp$6(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
	const VERSION$1 = "2018-10-31";
	const API_VERSION$1 = 2;
	const API_MINOR_VERSION$1 = 0;
	const ALLOWED_CARD_AUTH_METHODS$1 = ["PAN_ONLY", "CRYPTOGRAM_3DS"];
	const ALLOWED_CARD_NETWORKS$1 = [
	  "AMEX",
	  "DISCOVER",
	  "INTERAC",
	  "JCB",
	  "MASTERCARD",
	  "VISA"
	];
	class StripeGooglePayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    const method = __spreadProps$3(__spreadValues$6({}, methods.google), {
	      publishable_key: methods.card.publishable_key
	    });
	    super(request, options, params, method);
	  }
	  get scripts() {
	    return ["google-pay"];
	  }
	  get google() {
	    if (!window.google) {
	      throw new LibraryNotLoadedError("Google");
	    }
	    return window.google;
	  }
	  get googleClient() {
	    if (!StripeGooglePayment.googleClient) {
	      if (this.google) {
	        this.googleClient = new this.google.payments.api.PaymentsClient({
	          environment: isLiveMode(this.method.mode) ? "PRODUCTION" : "TEST"
	        });
	      }
	      if (!StripeGooglePayment.googleClient) {
	        throw new LibraryNotLoadedError("Google client");
	      }
	    }
	    return StripeGooglePayment.googleClient;
	  }
	  set googleClient(googleClient) {
	    StripeGooglePayment.googleClient = googleClient;
	  }
	  get tokenizationSpecification() {
	    const publishableKey = this.method.publishable_key;
	    if (!publishableKey) {
	      throw new Error("Stripe publishable key is not defined");
	    }
	    return {
	      type: "PAYMENT_GATEWAY",
	      parameters: {
	        gateway: "stripe",
	        "stripe:version": VERSION$1,
	        "stripe:publishableKey": publishableKey
	      }
	    };
	  }
	  get cardPaymentMethod() {
	    return {
	      type: "CARD",
	      tokenizationSpecification: this.tokenizationSpecification,
	      parameters: {
	        allowedAuthMethods: ALLOWED_CARD_AUTH_METHODS$1,
	        allowedCardNetworks: ALLOWED_CARD_NETWORKS$1,
	        billingAddressRequired: true,
	        billingAddressParameters: {
	          format: "FULL",
	          phoneNumberRequired: true
	        }
	      }
	    };
	  }
	  get allowedPaymentMethods() {
	    return [this.cardPaymentMethod];
	  }
	  async createElements() {
	    if (!this.method.merchant_id) {
	      throw new Error("Google merchant ID is not defined");
	    }
	    const isReadyToPay = await this.googleClient.isReadyToPay({
	      apiVersion: API_VERSION$1,
	      apiVersionMinor: API_MINOR_VERSION$1,
	      allowedPaymentMethods: this.allowedPaymentMethods,
	      existingPaymentMethodRequired: true
	    });
	    if (!isReadyToPay.result) {
	      throw new Error(
	        "This device is not capable of making Google Pay payments"
	      );
	    }
	    const cart = await this.getCart();
	    const paymentRequestData = this._createPaymentRequestData(cart);
	    this._renderButton(paymentRequestData);
	  }
	  _createPaymentRequestData(cart) {
	    const {
	      settings: { name },
	      capture_total,
	      currency
	    } = cart;
	    const { require: { email, shipping, phone } = {} } = this.params;
	    return {
	      apiVersion: API_VERSION$1,
	      apiVersionMinor: API_MINOR_VERSION$1,
	      transactionInfo: {
	        currencyCode: currency,
	        totalPrice: capture_total.toString(),
	        totalPriceStatus: "ESTIMATED"
	      },
	      allowedPaymentMethods: this.allowedPaymentMethods,
	      emailRequired: Boolean(email),
	      shippingAddressRequired: Boolean(shipping),
	      shippingAddressParameters: {
	        phoneNumberRequired: Boolean(phone)
	      },
	      merchantInfo: {
	        merchantName: name,
	        merchantId: this.method.merchant_id
	      }
	    };
	  }
	  _renderButton(paymentRequestData) {
	    const {
	      elementId = "googlepay-button",
	      locale = "en",
	      style: { color = "black", type = "buy", sizeMode = "fill" } = {},
	      classes = {}
	    } = this.params;
	    const container = document.getElementById(elementId);
	    if (!container) {
	      throw new DomElementNotFoundError(elementId);
	    }
	    if (classes.base) {
	      container.classList.add(classes.base);
	    }
	    const button = this.googleClient.createButton({
	      buttonColor: color,
	      buttonType: type,
	      buttonSizeMode: sizeMode,
	      buttonLocale: locale,
	      onClick: this._onClick.bind(this, paymentRequestData)
	    });
	    container.appendChild(button);
	  }
	  async _onClick(paymentRequestData) {
	    try {
	      const paymentData = await this.googleClient.loadPaymentData(
	        paymentRequestData
	      );
	      if (paymentData) {
	        await this._submitPayment(paymentData);
	      }
	    } catch (error) {
	      this.onError(error);
	    }
	  }
	  async _submitPayment(paymentData) {
	    const { require: { shipping: requireShipping } = {} } = this.params;
	    const { email, shippingAddress, paymentMethodData } = paymentData;
	    const {
	      info: { billingAddress },
	      tokenizationData
	    } = paymentMethodData;
	    const token = JSON.parse(tokenizationData.token);
	    const { card } = token;
	    await this.updateCart(__spreadValues$6({
	      account: {
	        email
	      },
	      billing: __spreadValues$6({
	        method: "card",
	        card: {
	          token: token.id,
	          brand: card.brand,
	          last4: card.last4,
	          exp_month: card.exp_month,
	          exp_year: card.exp_year,
	          gateway: "stripe"
	        }
	      }, this._mapAddress(billingAddress))
	    }, requireShipping && {
	      shipping: this._mapAddress(shippingAddress)
	    }));
	    this.onSuccess();
	  }
	  _mapAddress(address) {
	    return {
	      name: address.name,
	      address1: address.address1,
	      address2: address.address2,
	      city: address.locality,
	      state: address.administrativeArea,
	      zip: address.postalCode,
	      country: address.countryCode,
	      phone: address.phoneNumber
	    };
	  }
	}

	var __defProp$5 = Object.defineProperty;
	var __defProps$2 = Object.defineProperties;
	var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
	var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
	var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$5 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$5.call(b, prop))
	      __defNormalProp$5(a, prop, b[prop]);
	  if (__getOwnPropSymbols$5)
	    for (var prop of __getOwnPropSymbols$5(b)) {
	      if (__propIsEnum$5.call(b, prop))
	        __defNormalProp$5(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
	class StripeApplePayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    const method = __spreadProps$2(__spreadValues$5({}, methods.apple), {
	      publishable_key: methods.card.publishable_key
	    });
	    super(request, options, params, method);
	  }
	  get scripts() {
	    return ["stripe-js"];
	  }
	  get stripe() {
	    if (!StripeApplePayment.stripe) {
	      if (window.Stripe) {
	        this.stripe = window.Stripe(this.method.publishable_key);
	      }
	      if (!StripeApplePayment.stripe) {
	        throw new LibraryNotLoadedError("Stripe");
	      }
	    }
	    return StripeApplePayment.stripe;
	  }
	  set stripe(stripe) {
	    StripeApplePayment.stripe = stripe;
	  }
	  async createElements() {
	    await this._authorizeDomain();
	    const cart = await this.getCart();
	    const paymentRequest = this._createPaymentRequest(cart);
	    const canMakePayment = await paymentRequest.canMakePayment();
	    if (!canMakePayment || !canMakePayment.applePay) {
	      throw new Error(
	        "This device is not capable of making Apple Pay payments"
	      );
	    }
	    this._renderButton(paymentRequest);
	  }
	  async _authorizeDomain() {
	    const domain = window.location.hostname;
	    const authorization = await this.authorizeGateway({
	      gateway: "stripe",
	      params: {
	        applepay_domain: domain
	      }
	    });
	    if (!authorization) {
	      throw new Error(`${domain} domain is not verified`);
	    }
	  }
	  _createPaymentRequest(cart) {
	    const { require: { name, email, shipping, phone } = {} } = this.params;
	    const paymentRequest = this.stripe.paymentRequest(__spreadValues$5({
	      requestPayerName: Boolean(name),
	      requestPayerEmail: Boolean(email),
	      requestPayerPhone: Boolean(phone),
	      requestShipping: Boolean(shipping),
	      disableWallets: ["googlePay", "browserCard", "link"]
	    }, this._getPaymentRequestData(cart)));
	    paymentRequest.on(
	      "shippingaddresschange",
	      this._onShippingAddressChange.bind(this)
	    );
	    paymentRequest.on(
	      "shippingoptionchange",
	      this._onShippingOptionChange.bind(this)
	    );
	    paymentRequest.on("paymentmethod", this._onPaymentMethod.bind(this));
	    return paymentRequest;
	  }
	  _renderButton(paymentRequest) {
	    const {
	      elementId = "applepay-button",
	      style: { type = "default", theme = "dark", height = "40px" } = {},
	      classes = {}
	    } = this.params;
	    const container = document.getElementById(elementId);
	    if (!container) {
	      throw new DomElementNotFoundError(elementId);
	    }
	    const button = this.stripe.elements().create("paymentRequestButton", {
	      paymentRequest,
	      style: {
	        paymentRequestButton: {
	          type,
	          theme,
	          height
	        }
	      },
	      classes
	    });
	    button.mount(`#${elementId}`);
	  }
	  _getPaymentRequestData(cart) {
	    const {
	      currency,
	      shipping,
	      items,
	      capture_total,
	      shipment_rating,
	      shipment_total,
	      tax_included_total,
	      settings
	    } = cart;
	    const stripeCurrency = currency.toLowerCase();
	    const displayItems = items.map((item) => ({
	      label: item.product.name,
	      amount: stripeAmountByCurrency(
	        currency,
	        item.price_total - item.discount_total
	      )
	    }));
	    if (tax_included_total) {
	      displayItems.push({
	        label: "Taxes",
	        amount: stripeAmountByCurrency(currency, tax_included_total)
	      });
	    }
	    if (shipping.price && shipment_total) {
	      displayItems.push({
	        label: shipping.service_name,
	        amount: stripeAmountByCurrency(currency, shipment_total)
	      });
	    }
	    const services = shipment_rating && shipment_rating.services;
	    let shippingOptions;
	    if (services) {
	      shippingOptions = services.map((service) => ({
	        id: service.id,
	        label: service.name,
	        detail: service.description,
	        amount: stripeAmountByCurrency(currency, service.price)
	      }));
	    }
	    return {
	      country: settings.country,
	      currency: stripeCurrency,
	      total: {
	        label: settings.name,
	        amount: stripeAmountByCurrency(currency, capture_total),
	        pending: true
	      },
	      displayItems,
	      shippingOptions
	    };
	  }
	  async _onShippingAddressChange(event) {
	    const { shippingAddress, updateWith } = event;
	    const shipping = this._mapShippingAddress(shippingAddress);
	    const cart = await this.updateCart({
	      shipping: __spreadProps$2(__spreadValues$5({}, shipping), { service: null }),
	      shipment_rating: null
	    });
	    if (cart) {
	      updateWith(__spreadValues$5({ status: "success" }, this._getPaymentRequestData(cart)));
	    } else {
	      updateWith({ status: "invalid_shipping_address" });
	    }
	  }
	  async _onShippingOptionChange(event) {
	    const { shippingOption, updateWith } = event;
	    const cart = await this.updateCart({
	      shipping: { service: shippingOption.id }
	    });
	    if (cart) {
	      updateWith(__spreadValues$5({ status: "success" }, this._getPaymentRequestData(cart)));
	    } else {
	      updateWith({ status: "fail" });
	    }
	  }
	  async _onPaymentMethod(event) {
	    const {
	      payerEmail,
	      paymentMethod: { id: paymentMethod, card, billing_details },
	      shippingAddress,
	      shippingOption,
	      complete
	    } = event;
	    const { require: { shipping: requireShipping } = {} } = this.params;
	    await this.updateCart(__spreadProps$2(__spreadValues$5({
	      account: {
	        email: payerEmail
	      }
	    }, requireShipping && {
	      shipping: __spreadProps$2(__spreadValues$5({}, this._mapShippingAddress(shippingAddress)), {
	        service: shippingOption.id
	      })
	    }), {
	      billing: __spreadProps$2(__spreadValues$5({}, this._mapBillingAddress(billing_details)), {
	        method: "card",
	        card: {
	          gateway: "stripe",
	          token: paymentMethod,
	          brand: card.brand,
	          exp_month: card.exp_month,
	          exp_year: card.exp_year,
	          last4: card.last4,
	          address_check: card.checks.address_line1_check,
	          zip_check: card.checks.address_postal_code_check,
	          cvc_check: card.checks.cvc_check
	        }
	      })
	    }));
	    complete("success");
	    this.onSuccess();
	  }
	  _mapShippingAddress(address = {}) {
	    return {
	      name: address.recipient,
	      address1: address.addressLine[0],
	      address2: address.addressLine[1],
	      city: address.city,
	      state: address.region,
	      zip: address.postalCode,
	      country: address.country,
	      phone: address.phone
	    };
	  }
	  _mapBillingAddress(address = {}) {
	    return {
	      name: address.name,
	      phone: address.phone,
	      address1: address.address.line1,
	      address2: address.address.line2,
	      city: address.address.city,
	      state: address.address.state,
	      zip: address.address.postal_code,
	      country: address.address.country
	    };
	  }
	}

	class BraintreePaypalPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.paypal);
	  }
	  get scripts() {
	    const { client_id, merchant_id } = this.method;
	    return [
	      { id: "braintree-paypal-sdk", params: { client_id, merchant_id } },
	      "braintree-web",
	      "braintree-web-paypal-checkout"
	    ];
	  }
	  get paypal() {
	    if (!window.paypal) {
	      throw new LibraryNotLoadedError("PayPal");
	    }
	    return window.paypal;
	  }
	  get braintree() {
	    if (!window.braintree) {
	      throw new LibraryNotLoadedError("Braintree");
	    }
	    return window.braintree;
	  }
	  get braintreePaypalCheckout() {
	    if (!this.braintree.paypalCheckout) {
	      throw new LibraryNotLoadedError("Braintree PayPal Checkout");
	    }
	    return this.braintree.paypalCheckout;
	  }
	  async createElements() {
	    const cart = await this.getCart();
	    const authorization = await this.authorizeGateway({
	      gateway: "braintree"
	    });
	    if (authorization.error) {
	      throw new Error(authorization.error.message);
	    }
	    const braintreeClient = await this.braintree.client.create({
	      authorization
	    });
	    const paypalCheckout = await this.braintreePaypalCheckout.create({
	      client: braintreeClient
	    });
	    const button = this.paypal.Buttons({
	      style: this.params.style || {},
	      createBillingAgreement: this._onCreateBillingAgreement.bind(
	        this,
	        paypalCheckout,
	        cart
	      ),
	      onApprove: this._onApprove.bind(this, paypalCheckout),
	      onCancel: this.onCancel.bind(this),
	      onError: this.onError.bind(this)
	    });
	    button.render(this.params.elementId || "#paypal-button");
	  }
	  _onCreateBillingAgreement(paypalCheckout, cart) {
	    return paypalCheckout.createPayment({
	      flow: "vault",
	      currency: cart.currency,
	      amount: cart.capture_total
	    });
	  }
	  async _onApprove(paypalCheckout, data, actions) {
	    const { nonce } = await paypalCheckout.tokenizePayment(data);
	    await this.updateCart({
	      billing: {
	        method: "paypal",
	        paypal: {
	          nonce
	        }
	      }
	    });
	    this.onSuccess(data, actions);
	  }
	}

	var __defProp$4 = Object.defineProperty;
	var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
	var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
	var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$4 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$4.call(b, prop))
	      __defNormalProp$4(a, prop, b[prop]);
	  if (__getOwnPropSymbols$4)
	    for (var prop of __getOwnPropSymbols$4(b)) {
	      if (__propIsEnum$4.call(b, prop))
	        __defNormalProp$4(a, prop, b[prop]);
	    }
	  return a;
	};
	const API_VERSION = 2;
	const API_MINOR_VERSION = 0;
	const ALLOWED_CARD_AUTH_METHODS = ["PAN_ONLY", "CRYPTOGRAM_3DS"];
	const ALLOWED_CARD_NETWORKS = [
	  "AMEX",
	  "DISCOVER",
	  "INTERAC",
	  "JCB",
	  "MASTERCARD",
	  "VISA"
	];
	class BraintreeGooglePayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    super(request, options, params, methods.google);
	  }
	  get scripts() {
	    return ["google-pay", "braintree-web", "braintree-google-payment"];
	  }
	  get braintree() {
	    if (!window.braintree) {
	      throw new LibraryNotLoadedError("Braintree");
	    }
	    return window.braintree;
	  }
	  get google() {
	    if (!window.google) {
	      throw new LibraryNotLoadedError("Google");
	    }
	    return window.google;
	  }
	  get googleClient() {
	    if (!BraintreeGooglePayment.googleClient) {
	      if (this.google) {
	        this.googleClient = new this.google.payments.api.PaymentsClient({
	          environment: isLiveMode(this.method.mode) ? "PRODUCTION" : "TEST"
	        });
	      }
	      if (!BraintreeGooglePayment.googleClient) {
	        throw new LibraryNotLoadedError("Google client");
	      }
	    }
	    return BraintreeGooglePayment.googleClient;
	  }
	  set googleClient(googleClient) {
	    BraintreeGooglePayment.googleClient = googleClient;
	  }
	  get cardPaymentMethod() {
	    return {
	      type: "CARD",
	      parameters: {
	        allowedAuthMethods: ALLOWED_CARD_AUTH_METHODS,
	        allowedCardNetworks: ALLOWED_CARD_NETWORKS,
	        billingAddressRequired: true,
	        billingAddressParameters: {
	          format: "FULL",
	          phoneNumberRequired: true
	        }
	      }
	    };
	  }
	  get allowedPaymentMethods() {
	    return [this.cardPaymentMethod];
	  }
	  async createElements() {
	    if (!this.method.merchant_id) {
	      throw new Error("Google merchant ID is not defined");
	    }
	    const isReadyToPay = await this.googleClient.isReadyToPay({
	      apiVersion: API_VERSION,
	      apiVersionMinor: API_MINOR_VERSION,
	      allowedPaymentMethods: this.allowedPaymentMethods,
	      existingPaymentMethodRequired: true
	    });
	    if (!isReadyToPay.result) {
	      throw new Error(
	        "This device is not capable of making Google Pay payments"
	      );
	    }
	    const braintreeClient = await this._createBraintreeClient();
	    const googlePayment = await this.braintree.googlePayment.create({
	      client: braintreeClient,
	      googleMerchantId: this.method.merchant_id,
	      googlePayVersion: API_VERSION
	    });
	    const cart = await this.getCart();
	    const paymentRequestData = this._createPaymentRequestData(cart);
	    const paymentDataRequest = googlePayment.createPaymentDataRequest(paymentRequestData);
	    this._renderButton(googlePayment, paymentDataRequest);
	  }
	  async _createBraintreeClient() {
	    const authorization = await this.authorizeGateway({
	      gateway: "braintree"
	    });
	    if (authorization.error) {
	      throw new Error(authorization.error.message);
	    }
	    return this.braintree.client.create({
	      authorization
	    });
	  }
	  _createPaymentRequestData(cart) {
	    const {
	      settings: { name },
	      capture_total,
	      currency
	    } = cart;
	    const { require: { email, shipping, phone } = {} } = this.params;
	    return {
	      apiVersion: API_VERSION,
	      apiVersionMinor: API_MINOR_VERSION,
	      transactionInfo: {
	        currencyCode: currency,
	        totalPrice: capture_total.toString(),
	        totalPriceStatus: "ESTIMATED"
	      },
	      allowedPaymentMethods: this.allowedPaymentMethods,
	      emailRequired: Boolean(email),
	      shippingAddressRequired: Boolean(shipping),
	      shippingAddressParameters: {
	        phoneNumberRequired: Boolean(phone)
	      },
	      merchantInfo: {
	        merchantName: name,
	        merchantId: this.method.merchant_id
	      }
	    };
	  }
	  _renderButton(googlePayment, paymentDataRequest) {
	    const {
	      elementId = "googlepay-button",
	      locale = "en",
	      style: { color = "black", type = "buy", sizeMode = "fill" } = {},
	      classes = {}
	    } = this.params;
	    const container = document.getElementById(elementId);
	    if (!container) {
	      throw new DomElementNotFoundError(elementId);
	    }
	    if (classes.base) {
	      container.classList.add(classes.base);
	    }
	    const button = this.googleClient.createButton({
	      buttonColor: color,
	      buttonType: type,
	      buttonSizeMode: sizeMode,
	      buttonLocale: locale,
	      onClick: this._onClick.bind(this, googlePayment, paymentDataRequest)
	    });
	    container.appendChild(button);
	  }
	  async _onClick(googlePayment, paymentDataRequest) {
	    try {
	      const paymentData = await this.googleClient.loadPaymentData(
	        paymentDataRequest
	      );
	      if (paymentData) {
	        await this._submitPayment(googlePayment, paymentData);
	      }
	    } catch (error) {
	      this.onError(error);
	    }
	  }
	  async _submitPayment(googlePayment, paymentData) {
	    const { require: { shipping: requireShipping } = {} } = this.params;
	    const { nonce } = await googlePayment.parseResponse(paymentData);
	    const { email, shippingAddress, paymentMethodData } = paymentData;
	    const {
	      info: { billingAddress }
	    } = paymentMethodData;
	    await this.updateCart(__spreadValues$4({
	      account: {
	        email
	      },
	      billing: __spreadValues$4({
	        method: "google",
	        google: {
	          nonce,
	          gateway: "braintree"
	        }
	      }, this._mapAddress(billingAddress))
	    }, requireShipping && {
	      shipping: this._mapAddress(shippingAddress)
	    }));
	    this.onSuccess();
	  }
	  _mapAddress(address) {
	    return {
	      name: address.name,
	      address1: address.address1,
	      address2: address.address2,
	      city: address.locality,
	      state: address.administrativeArea,
	      zip: address.postalCode,
	      country: address.countryCode,
	      phone: address.phoneNumber
	    };
	  }
	}

	var __defProp$3 = Object.defineProperty;
	var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
	var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
	var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$3 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$3.call(b, prop))
	      __defNormalProp$3(a, prop, b[prop]);
	  if (__getOwnPropSymbols$3)
	    for (var prop of __getOwnPropSymbols$3(b)) {
	      if (__propIsEnum$3.call(b, prop))
	        __defNormalProp$3(a, prop, b[prop]);
	    }
	  return a;
	};
	const VERSION = 3;
	const MERCHANT_CAPABILITIES = [
	  "supports3DS",
	  "supportsDebit",
	  "supportsCredit"
	];
	class BraintreeApplePayment extends Payment {
	  constructor(request, options, params, methods) {
	    if (!methods.card) {
	      throw new PaymentMethodDisabledError("Credit cards");
	    }
	    super(request, options, params, methods.apple);
	  }
	  get scripts() {
	    return ["braintree-web", "braintree-apple-payment"];
	  }
	  get braintree() {
	    if (!window.braintree) {
	      throw new LibraryNotLoadedError("Braintree");
	    }
	    return window.braintree;
	  }
	  get ApplePaySession() {
	    if (!window.ApplePaySession) {
	      throw new LibraryNotLoadedError("Apple");
	    }
	    return window.ApplePaySession;
	  }
	  async createElements() {
	    if (!this.ApplePaySession.canMakePayments()) {
	      throw new Error(
	        "This device is not capable of making Apple Pay payments"
	      );
	    }
	    const cart = await this.getCart();
	    const braintreeClient = await this._createBraintreeClient();
	    const applePayment = await this.braintree.applePay.create({
	      client: braintreeClient
	    });
	    const paymentRequest = await this._createPaymentRequest(cart, applePayment);
	    this._renderButton(applePayment, paymentRequest);
	  }
	  _renderButton(applePayment, paymentRequest) {
	    const {
	      elementId = "applepay-button",
	      style: { type = "plain", theme = "black", height = "40px" } = {},
	      classes = {}
	    } = this.params;
	    const container = document.getElementById(elementId);
	    if (!container) {
	      throw new DomElementNotFoundError(elementId);
	    }
	    if (classes.base) {
	      container.classList.add(classes.base);
	    }
	    const button = document.createElement("div");
	    button.style.appearance = "-apple-pay-button";
	    button.style["-apple-pay-button-type"] = type;
	    button.style["-apple-pay-button-style"] = theme;
	    button.style.height = height;
	    button.addEventListener(
	      "click",
	      this._createPaymentSession.bind(this, applePayment, paymentRequest)
	    );
	    container.appendChild(button);
	  }
	  async _createBraintreeClient() {
	    const authorization = await this.authorizeGateway({
	      gateway: "braintree"
	    });
	    if (authorization.error) {
	      throw new Error(authorization.error.message);
	    }
	    return this.braintree.client.create({
	      authorization
	    });
	  }
	  _createPaymentRequest(cart, applePayment) {
	    const { require: require2 = {} } = this.params;
	    const {
	      settings: { name },
	      capture_total,
	      currency
	    } = cart;
	    const requiredShippingContactFields = [];
	    const requiredBillingContactFields = ["postalAddress"];
	    if (require2.name) {
	      requiredShippingContactFields.push("name");
	    }
	    if (require2.email) {
	      requiredShippingContactFields.push("email");
	    }
	    if (require2.phone) {
	      requiredShippingContactFields.push("phone");
	    }
	    if (require2.shipping) {
	      requiredShippingContactFields.push("postalAddress");
	    }
	    return applePayment.createPaymentRequest({
	      total: {
	        label: name,
	        type: "pending",
	        amount: capture_total.toString()
	      },
	      currencyCode: currency,
	      merchantCapabilities: MERCHANT_CAPABILITIES,
	      requiredShippingContactFields,
	      requiredBillingContactFields
	    });
	  }
	  _createPaymentSession(applePayment, paymentRequest) {
	    const session = new this.ApplePaySession(VERSION, paymentRequest);
	    session.onvalidatemerchant = async (event) => {
	      const merchantSession = await applePayment.performValidation({
	        validationURL: event.validationURL,
	        displayName: paymentRequest.total.label
	      }).catch(this.onError.bind(this));
	      if (merchantSession) {
	        session.completeMerchantValidation(merchantSession);
	      } else {
	        session.abort();
	      }
	    };
	    session.onpaymentauthorized = async (event) => {
	      const {
	        payment: { token, shippingContact, billingContact }
	      } = event;
	      const { require: { shipping: requireShipping } = {} } = this.params;
	      const payload = await applePayment.tokenize({ token }).catch(this.onError.bind(this));
	      if (!payload) {
	        return session.completePayment(this.ApplePaySession.STATUS_FAILURE);
	      }
	      await this.updateCart(__spreadValues$3({
	        account: {
	          email: shippingContact.emailAddress
	        },
	        billing: __spreadValues$3({
	          method: "apple",
	          apple: {
	            nonce: payload.nonce,
	            gateway: "braintree"
	          }
	        }, this._mapAddress(billingContact))
	      }, requireShipping && {
	        shipping: this._mapAddress(shippingContact)
	      }));
	      this.onSuccess();
	      return session.completePayment(this.ApplePaySession.STATUS_SUCCESS);
	    };
	    session.begin();
	  }
	  _mapAddress(address = {}) {
	    return {
	      first_name: address.givenName,
	      last_name: address.familyName,
	      address1: address.addressLines[0],
	      address2: address.addressLines[1],
	      city: address.locality,
	      state: address.administrativeArea,
	      zip: address.postalCode,
	      country: address.countryCode,
	      phone: address.phoneNumber
	    };
	  }
	}

	class QuickpayCardPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.card);
	  }
	  get orderId() {
	    return Math.random().toString(36).substr(2, 9);
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const intent = await this.createIntent({
	      gateway: "quickpay",
	      intent: {
	        order_id: this.orderId,
	        currency: cart.currency || "USD"
	      }
	    });
	    await this.updateCart({
	      billing: {
	        method: "card",
	        intent: {
	          quickpay: {
	            id: intent
	          }
	        }
	      }
	    });
	    const returnUrl = window.location.origin + window.location.pathname;
	    const authorization = await this.authorizeGateway({
	      gateway: "quickpay",
	      params: {
	        action: "create",
	        continueurl: `${returnUrl}?gateway=quickpay&redirect_status=succeeded`,
	        cancelurl: `${returnUrl}?gateway=quickpay&redirect_status=canceled`
	      }
	    });
	    if (authorization && authorization.url) {
	      window.location.replace(authorization.url);
	    }
	  }
	  async handleRedirect(queryParams) {
	    const { redirect_status: status, card_id: id } = queryParams;
	    switch (status) {
	      case "succeeded":
	        return this._handleSuccessfulRedirect(id);
	      case "canceled":
	        throw new UnableAuthenticatePaymentMethodError();
	      default:
	        throw new Error(`Unknown redirect status: ${status}`);
	    }
	  }
	  async _handleSuccessfulRedirect(cardId) {
	    const card = await this.authorizeGateway({
	      gateway: "quickpay",
	      params: { action: "get", id: cardId }
	    });
	    if (card.error) {
	      throw new Error(card.error.message);
	    }
	    await this.updateCart({
	      billing: {
	        method: "card",
	        card
	      }
	    });
	    this.onSuccess();
	  }
	}

	function createPaysafecardPaymentData(cart) {
	  const returnUrl = window.location.origin + window.location.pathname;
	  const url = `${returnUrl}?gateway=paysafecard`;
	  return {
	    type: "PAYSAFECARD",
	    amount: cart.capture_total,
	    redirect: {
	      success_url: url,
	      failure_url: url
	    },
	    notification_url: url,
	    customer: {
	      id: get(cart, "account.id")
	    },
	    currency: get(cart, "currency", "USD")
	  };
	}

	class PaysafecardDirectPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.paysafecard);
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const intentData = createPaysafecardPaymentData(cart);
	    const intent = await this.createIntent({
	      gateway: "paysafecard",
	      intent: intentData
	    });
	    if (!intent) {
	      throw new Error("Paysafecard payment is not defined");
	    }
	    await this.updateCart({
	      billing: {
	        method: "paysafecard",
	        intent: {
	          paysafecard: {
	            id: intent.id
	          }
	        }
	      }
	    });
	    window.location.replace(intent.redirect.auth_url);
	  }
	  async handleRedirect() {
	    const cart = await this.getCart();
	    const paymentId = get(cart, "billing.intent.paysafecard.id");
	    if (!paymentId) {
	      throw new Error("Paysafecard payment ID is not defined");
	    }
	    const intent = await this.updateIntent({
	      gateway: "paysafecard",
	      intent: { payment_id: paymentId }
	    });
	    if (!intent) {
	      throw new Error("Paysafecard payment is not defined");
	    }
	    switch (intent.status) {
	      case "SUCCESS":
	      case "AUTHORIZED":
	        return this.onSuccess();
	      case "CANCELED_CUSTOMER":
	        throw new UnableAuthenticatePaymentMethodError();
	      default:
	        throw new Error(`Unknown redirect status: ${intent.status}.`);
	    }
	  }
	}

	var __defProp$2 = Object.defineProperty;
	var __defProps$1 = Object.defineProperties;
	var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
	var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
	var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$2 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$2.call(b, prop))
	      __defNormalProp$2(a, prop, b[prop]);
	  if (__getOwnPropSymbols$2)
	    for (var prop of __getOwnPropSymbols$2(b)) {
	      if (__propIsEnum$2.call(b, prop))
	        __defNormalProp$2(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
	const addressFieldsMap = {
	  given_name: "first_name",
	  family_name: "last_name",
	  city: "city",
	  country: "country",
	  phone: "phone",
	  postal_code: "zip",
	  street_address: "address1",
	  street_address2: "address2",
	  region: "state"
	};
	const mapFields = (fieldsMap, data) => reduce(
	  fieldsMap,
	  (acc, srcKey, destKey) => {
	    const value = data[srcKey];
	    if (value) {
	      acc[destKey] = value;
	    }
	    return acc;
	  },
	  {}
	);
	const mapAddressFields = (cart, addressField) => __spreadProps$1(__spreadValues$2({}, mapFields(addressFieldsMap, cart[addressField])), {
	  email: get(cart, "account.email")
	});
	function getOrderLines(cart) {
	  const items = map(cart.items, (item) => ({
	    type: "physical",
	    name: get(item, "product.name"),
	    reference: get(item, "product.sku") || get(item, "product.slug"),
	    quantity: item.quantity,
	    unit_price: Math.round(toNumber(item.price - item.discount_each) * 100),
	    total_amount: Math.round(
	      toNumber(item.price_total - item.discount_total) * 100
	    ),
	    tax_rate: 0,
	    total_tax_amount: 0
	  }));
	  const tax = get(cart, "tax_included_total");
	  const taxAmount = toNumber(tax) * 100;
	  if (tax) {
	    items.push({
	      type: "sales_tax",
	      name: "Taxes",
	      quantity: 1,
	      unit_price: taxAmount,
	      total_amount: taxAmount,
	      tax_rate: 0,
	      total_tax_amount: 0
	    });
	  }
	  const shipping = get(cart, "shipping", {});
	  const shippingTotal = get(cart, "shipment_total", {});
	  const shippingAmount = toNumber(shippingTotal) * 100;
	  if (shipping.price) {
	    items.push({
	      type: "shipping_fee",
	      name: shipping.service_name,
	      quantity: 1,
	      unit_price: shippingAmount,
	      total_amount: shippingAmount,
	      tax_rate: 0,
	      total_tax_amount: 0
	    });
	  }
	  return items;
	}
	function getKlarnaSessionData(cart) {
	  const returnUrl = `${window.location.origin}${window.location.pathname}?gateway=klarna_direct&sid={{session_id}}`;
	  const successUrl = `${returnUrl}&authorization_token={{authorization_token}}`;
	  return {
	    locale: cart.display_locale || get(cart, "settings.locale") || "en-US",
	    purchase_country: get(cart, "billing.country") || get(cart, "shipping.country"),
	    purchase_currency: cart.currency,
	    billing_address: mapAddressFields(cart, "billing"),
	    shipping_address: mapAddressFields(cart, "shipping"),
	    order_amount: Math.round(get(cart, "capture_total", 0) * 100),
	    order_lines: JSON.stringify(getOrderLines(cart)),
	    merchant_urls: {
	      success: successUrl,
	      back: returnUrl,
	      cancel: returnUrl,
	      error: returnUrl,
	      failure: returnUrl
	    }
	  };
	}

	class KlarnaDirectPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.klarna);
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const sessionData = getKlarnaSessionData(cart);
	    const session = await this.createIntent({
	      gateway: "klarna",
	      intent: sessionData
	    });
	    if (!session) {
	      throw new Error("Klarna session is not defined");
	    }
	    window.location.replace(session.redirect_url);
	  }
	  async handleRedirect(queryParams) {
	    const { authorization_token } = queryParams;
	    if (!authorization_token) {
	      throw new UnableAuthenticatePaymentMethodError();
	    }
	    await this.updateCart({
	      billing: {
	        method: "klarna",
	        klarna: {
	          token: authorization_token
	        }
	      }
	    });
	    this.onSuccess();
	  }
	}

	class PaypalDirectPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.paypal);
	  }
	  get scripts() {
	    const { client_id, merchant_id } = this.method;
	    return [
	      {
	        id: "paypal-sdk",
	        params: {
	          client_id,
	          merchant_id,
	          cart: ["currency"]
	        }
	      }
	    ];
	  }
	  get paypal() {
	    if (!window.paypal) {
	      throw new LibraryNotLoadedError("PayPal");
	    }
	    return window.paypal;
	  }
	  async createElements() {
	    const cart = await this.getCart();
	    const { locale, style, elementId } = this.params;
	    if (!(cart.capture_total > 0)) {
	      throw new Error(
	        "Invalid PayPal button amount. Value should be greater than zero."
	      );
	    }
	    const button = this.paypal.Buttons({
	      locale: locale || "en_US",
	      style: style || {
	        layout: "horizontal",
	        height: 45,
	        color: "gold",
	        shape: "rect",
	        label: "paypal",
	        tagline: false
	      },
	      createOrder: this._onCreateOrder.bind(this, cart),
	      onApprove: this._onApprove.bind(this, cart),
	      onError: this.onError.bind(this)
	    });
	    button.render(elementId || "#paypal-button");
	  }
	  _onCreateOrder(cart, data, actions) {
	    const { capture_total, currency } = cart;
	    return actions.order.create({
	      intent: "AUTHORIZE",
	      purchase_units: [
	        {
	          amount: {
	            value: +capture_total.toFixed(2),
	            currency_code: currency
	          }
	        }
	      ]
	    });
	  }
	  async _onApprove(cart, data, actions) {
	    const order = await actions.order.get();
	    const orderId = order.id;
	    const payer = order.payer;
	    const shipping = get(order, "purchase_units[0].shipping");
	    await this.updateCart({
	      account: {
	        email: payer.email_address
	      },
	      billing: {
	        method: "paypal",
	        paypal: {
	          order_id: orderId
	        }
	      },
	      shipping: {
	        name: shipping.name.full_name,
	        address1: shipping.address.address_line_1,
	        address2: shipping.address.address_line_2,
	        state: shipping.address.admin_area_1,
	        city: shipping.address.admin_area_2,
	        zip: shipping.address.postal_code,
	        country: shipping.address.country_code
	      }
	    });
	    this.onSuccess();
	  }
	}

	var __defProp$1 = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
	var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
	var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$1 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$1.call(b, prop))
	      __defNormalProp$1(a, prop, b[prop]);
	  if (__getOwnPropSymbols$1)
	    for (var prop of __getOwnPropSymbols$1(b)) {
	      if (__propIsEnum$1.call(b, prop))
	        __defNormalProp$1(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	class AmazonDirectPayment extends Payment {
	  constructor(request, options, params, methods) {
	    super(request, options, params, methods.amazon);
	  }
	  get scripts() {
	    return ["amazon-checkout"];
	  }
	  get amazon() {
	    if (!window.amazon) {
	      throw new LibraryNotLoadedError("Amazon");
	    }
	    return window.amazon;
	  }
	  get merchantId() {
	    const merchantId = this.method.merchant_id;
	    if (!merchantId) {
	      throw new MethodPropertyMissingError("Amazon", "merchant_id");
	    }
	    return merchantId;
	  }
	  get publicKeyId() {
	    const publicKeyId = this.method.public_key_id;
	    if (!publicKeyId) {
	      throw new MethodPropertyMissingError("Amazon", "public_key_id");
	    }
	    return publicKeyId;
	  }
	  get returnUrl() {
	    return `${window.location.origin + window.location.pathname}?gateway=amazon`;
	  }
	  async createElements() {
	    const cart = await this.getCart();
	    const returnUrl = this.returnUrl;
	    const isSubscription = Boolean(cart.subscription_delivery);
	    const session = await this.authorizeGateway({
	      gateway: "amazon",
	      params: __spreadProps(__spreadValues$1({
	        chargePermissionType: isSubscription ? "Recurring" : "OneTime"
	      }, isSubscription ? {
	        recurringMetadata: {
	          frequency: {
	            unit: "Variable",
	            value: "0"
	          }
	        }
	      } : {}), {
	        webCheckoutDetails: {
	          checkoutReviewReturnUrl: `${returnUrl}&redirect_status=succeeded`,
	          checkoutCancelUrl: `${returnUrl}&redirect_status=canceled`
	        }
	      })
	    });
	    this._renderButton(cart, session);
	  }
	  async tokenize() {
	    const cart = await this.getCart();
	    const returnUrl = this.returnUrl;
	    const checkoutSessionId = get(cart, "billing.amazon.checkout_session_id");
	    if (!checkoutSessionId) {
	      throw new Error(
	        "Missing Amazon Pay checkout session ID (billing.amazon.checkout_session_id)"
	      );
	    }
	    const intent = await this.createIntent({
	      gateway: "amazon",
	      intent: {
	        checkoutSessionId,
	        webCheckoutDetails: {
	          checkoutResultReturnUrl: `${returnUrl}&confirm=true&redirect_status=succeeded`,
	          checkoutCancelUrl: `${returnUrl}&redirect_status=canceled`
	        },
	        paymentDetails: cart.capture_total > 0 ? {
	          paymentIntent: "Authorize",
	          canHandlePendingAuthorization: true,
	          chargeAmount: {
	            amount: cart.capture_total,
	            currencyCode: cart.currency
	          }
	        } : {
	          paymentIntent: "Confirm"
	        }
	      }
	    });
	    return window.location.replace(intent.redirect_url);
	  }
	  async handleRedirect(queryParams) {
	    const { redirect_status } = queryParams;
	    switch (redirect_status) {
	      case "succeeded":
	        return this._handleSuccessfulRedirect(queryParams);
	      case "canceled":
	        throw new UnableAuthenticatePaymentMethodError();
	      default:
	        throw new Error(`Unknown redirect status: ${redirect_status}`);
	    }
	  }
	  _renderButton(cart, session) {
	    const amazon = this.amazon;
	    const merchantId = this.merchantId;
	    const publicKeyId = this.publicKeyId;
	    const { payload: payloadJSON, signature } = session;
	    const {
	      elementId = "amazonpay-button",
	      locale = "en_US",
	      placement = "Checkout",
	      style: { color = "Gold" } = {},
	      require: { shipping: requireShipping } = {},
	      classes = {}
	    } = this.params;
	    const container = document.getElementById(elementId);
	    if (!container) {
	      throw new DomElementNotFoundError(elementId);
	    }
	    amazon.Pay.renderButton(`#${elementId}`, {
	      ledgerCurrency: cart.currency,
	      checkoutLanguage: locale,
	      productType: Boolean(requireShipping) ? "PayAndShip" : "PayOnly",
	      buttonColor: color,
	      placement,
	      merchantId,
	      publicKeyId,
	      createCheckoutSessionConfig: {
	        payloadJSON,
	        signature
	      }
	    });
	    if (classes.base) {
	      container.classList.add(classes.base);
	    }
	  }
	  async _handleSuccessfulRedirect(queryParams) {
	    const { confirm, amazonCheckoutSessionId } = queryParams;
	    if (!confirm) {
	      await this.updateCart({
	        billing: {
	          method: "amazon",
	          amazon: {
	            checkout_session_id: amazonCheckoutSessionId
	          }
	        }
	      });
	    }
	    this.onSuccess();
	  }
	}

	class PaymentController {
	  constructor(request, options) {
	    this.request = request;
	    this.options = options;
	  }
	  get(id) {
	    return this.request("get", "/payments", id);
	  }
	  async methods() {
	    if (this.methodSettings) {
	      return this.methodSettings;
	    }
	    this.methodSettings = await this.request("get", "/payment/methods");
	    return this.methodSettings;
	  }
	  async createElements(params) {
	    this.params = params;
	    if (!params) {
	      throw new Error("Payment element parameters are not provided");
	    }
	    this._performPaymentAction("createElements");
	  }
	  async tokenize(params = this.params) {
	    this.params = params;
	    if (!this.params) {
	      throw new Error("Tokenization parameters are not provided");
	    }
	    this._performPaymentAction("tokenize");
	  }
	  async handleRedirect(params = this.params) {
	    const queryParams = getLocationParams(window.location);
	    if (!queryParams || !queryParams.gateway) {
	      return;
	    }
	    this.params = params;
	    if (!params) {
	      throw new Error("Redirect parameters are not provided");
	    }
	    removeUrlParams();
	    this._performPaymentAction("handleRedirect", queryParams);
	  }
	  async authenticate(id) {
	    try {
	      const payment = await this.get(id);
	      if (!payment) {
	        throw new Error("Payment not found");
	      }
	      const { method, gateway } = payment;
	      const PaymentClass = this._getPaymentClass(method, gateway);
	      if (!PaymentClass) {
	        throw new UnsupportedPaymentMethodError(method, gateway);
	      }
	      const paymentMethods = await this._getPaymentMethods();
	      const methodSettings = paymentMethods[method];
	      if (!methodSettings) {
	        throw new PaymentMethodDisabledError(method);
	      }
	      const paymentInstance = new PaymentClass(
	        this.request,
	        this.options,
	        null,
	        paymentMethods
	      );
	      await paymentInstance.loadScripts(paymentInstance.scripts);
	      return await paymentInstance.authenticate(payment);
	    } catch (error) {
	      return { error };
	    }
	  }
	  async createIntent(data) {
	    return this._vaultRequest("post", "/intent", data);
	  }
	  async updateIntent(data) {
	    return this._vaultRequest("put", "/intent", data);
	  }
	  async authorizeGateway(data) {
	    return this._vaultRequest("post", "/authorization", data);
	  }
	  _normalizeParams() {
	    if (!this.params) {
	      return;
	    }
	    if (this.params.config) {
	      console.warn(
	        'Please move the "config" field to the payment method parameters ("card.config" or/and "ideal.config").'
	      );
	      if (this.params.card) {
	        this.params.card.config = this.params.config;
	      }
	      if (this.params.ideal) {
	        this.params.ideal.config = this.params.config;
	      }
	      delete this.params.config;
	    }
	  }
	  async _getPaymentMethods() {
	    const paymentMethods = await methods$2(
	      this.request,
	      this.options
	    ).payments();
	    if (paymentMethods.error) {
	      throw new Error(paymentMethods.error);
	    }
	    return toSnake(paymentMethods);
	  }
	  async _vaultRequest(method, url, data) {
	    const response = await vaultRequest(method, url, data);
	    if (response.errors) {
	      const param = Object.keys(response.errors)[0];
	      const err = new Error(response.errors[param].message || "Unknown error");
	      err.code = "vault_error";
	      err.status = 402;
	      err.param = param;
	      throw err;
	    }
	    if (this.options.useCamelCase) {
	      return toCamel(response);
	    }
	    return response;
	  }
	  async _performPaymentAction(action, ...args) {
	    const paymentMethods = await this._getPaymentMethods();
	    this._normalizeParams();
	    Object.entries(this.params).forEach(([method, params]) => {
	      const methodSettings = paymentMethods[method];
	      if (!methodSettings) {
	        return console.error(new PaymentMethodDisabledError(method));
	      }
	      const PaymentClass = this._getPaymentClass(
	        method,
	        methodSettings.gateway
	      );
	      if (!PaymentClass) {
	        return console.error(
	          new UnsupportedPaymentMethodError(method, methodSettings.gateway)
	        );
	      }
	      try {
	        const payment = new PaymentClass(
	          this.request,
	          this.options,
	          params,
	          paymentMethods
	        );
	        payment.loadScripts(payment.scripts).then(payment[action].bind(payment, ...args)).catch(payment.onError.bind(payment));
	      } catch (error) {
	        return console.error(error.message);
	      }
	    });
	  }
	  _getPaymentClass(method, gateway) {
	    switch (method) {
	      case "card":
	        return this._getCardPaymentClass(gateway);
	      case "ideal":
	        return this._getIDealPaymentClass(gateway);
	      case "bancontact":
	        return this._getBancontactPaymentClass(gateway);
	      case "klarna":
	        return this._getKlarnaPaymentClass(gateway);
	      case "paysafecard":
	        return this._getPaysafecardPaymentClass(gateway);
	      case "paypal":
	        return this._getPaypalPaymentClass(gateway);
	      case "google":
	        return this._getGooglePaymentClass(gateway);
	      case "apple":
	        return this._getApplePaymentClass(gateway);
	      case "amazon":
	        return this._getAmazonPaymentClass(gateway);
	      default:
	        return null;
	    }
	  }
	  _getCardPaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeCardPayment;
	      case "quickpay":
	        return QuickpayCardPayment;
	      default:
	        return null;
	    }
	  }
	  _getIDealPaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeIDealPayment;
	      default:
	        return null;
	    }
	  }
	  _getBancontactPaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeBancontactPayment;
	      default:
	        return null;
	    }
	  }
	  _getKlarnaPaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeKlarnaPayment;
	      case "klarna":
	        return KlarnaDirectPayment;
	      default:
	        return null;
	    }
	  }
	  _getPaysafecardPaymentClass(gateway) {
	    switch (gateway) {
	      default:
	        return PaysafecardDirectPayment;
	    }
	  }
	  _getPaypalPaymentClass(gateway) {
	    switch (gateway) {
	      case "braintree":
	        return BraintreePaypalPayment;
	      default:
	        return PaypalDirectPayment;
	    }
	  }
	  _getGooglePaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeGooglePayment;
	      case "braintree":
	        return BraintreeGooglePayment;
	      default:
	        return null;
	    }
	  }
	  _getApplePaymentClass(gateway) {
	    switch (gateway) {
	      case "stripe":
	        return StripeApplePayment;
	      case "braintree":
	        return BraintreeApplePayment;
	      default:
	        return null;
	    }
	  }
	  _getAmazonPaymentClass(gateway) {
	    switch (gateway) {
	      default:
	        return AmazonDirectPayment;
	    }
	  }
	}

	function methods$1(request, opt) {
	  return {
	    code: null,
	    state: null,
	    list() {
	      return opt.api.settings.get("store.locales", []);
	    },
	    async select(locale) {
	      this.set(locale);
	      setCookie("swell-locale", locale);
	      opt.api.settings.locale = locale;
	      return await request("put", "/session", { locale });
	    },
	    selected() {
	      if (this.code) {
	        return this.code;
	      }
	      const storeLocale = opt.api.settings.getStoreLocale();
	      const cookieLocale = getCookie("swell-locale");
	      opt.api.settings.locale = cookieLocale || storeLocale;
	      return cookieLocale || storeLocale;
	    },
	    get() {
	      if (!this.code) {
	        this.code = this.selected();
	      }
	      if (!this.state) {
	        this.state = this.set(this.code);
	      }
	      return this.state;
	    },
	    set(code) {
	      this.code = code;
	      this.state = find(this.list(), { code }) || {};
	      return this.state;
	    }
	  };
	}

	const FORMATTERS = {};
	function methods(request, opt) {
	  return {
	    code: null,
	    state: null,
	    locale: null,
	    list() {
	      return opt.api.settings.get("store.currencies", []);
	    },
	    async select(currency) {
	      this.set(currency);
	      return request("put", "/session", { currency });
	    },
	    selected() {
	      if (!this.code) {
	        this.set(
	          getCookie("swell-currency") || opt.api.settings.get("store.currency")
	        );
	      }
	      return this.code;
	    },
	    get() {
	      if (!this.code) {
	        this.code = this.selected();
	      }
	      if (!this.state) {
	        this.state = this.set(this.code);
	      }
	      return this.state;
	    },
	    set(code = "USD") {
	      this.code = code;
	      this.state = find(this.list(), { code }) || { code };
	      this.locale = String(
	        opt.api.settings.get(
	          "store.locale",
	          typeof navigator === "object" ? navigator.language : "en-US"
	        )
	      );
	      setCookie("swell-currency", code);
	      return this.state;
	    },
	    format(amount, params = {}) {
	      let state = this.get();
	      if (params.code && params.code !== state.code) {
	        const list = this.list();
	        state = find(list, { code: params.code }) || { code: params.code };
	      }
	      const { code = "USD", type, decimals, rate } = state;
	      const formatCode = params.code || code;
	      const formatRate = params.rate || rate;
	      const formatLocale = params.locale || this.locale;
	      const formatDecimals = typeof params.decimals === "number" ? params.decimals : decimals;
	      const { convert = true } = params;
	      let formatAmount = amount;
	      if (convert && (type === "display" || params.rate) && typeof formatAmount === "number" && typeof formatRate === "number") {
	        formatAmount = this.applyRounding(amount * formatRate, state);
	      }
	      const formatter = this.formatter({
	        code: formatCode,
	        locale: formatLocale,
	        decimals: formatDecimals
	      });
	      try {
	        if (typeof formatAmount === "number") {
	          return formatter.format(formatAmount);
	        } else {
	          const symbol = get(formatter.formatToParts(0), "0.value", "$");
	          return symbol !== formatCode ? symbol : "";
	        }
	      } catch (err) {
	        console.warn(err);
	      }
	      return String(amount);
	    },
	    formatter({ code, locale, decimals }) {
	      locale = String(locale || "").replace("_", "-");
	      const key = [code, locale, decimals].join("|");
	      if (FORMATTERS[key]) {
	        return FORMATTERS[key];
	      }
	      const formatLocales = [];
	      if (locale) {
	        formatLocales.push(locale);
	      }
	      formatLocales.push("en-US");
	      const formatDecimals = typeof decimals === "number" ? decimals : void 0;
	      const props = {
	        style: "currency",
	        currency: code,
	        currencyDisplay: "symbol",
	        minimumFractionDigits: formatDecimals,
	        maximumFractionDigits: formatDecimals
	      };
	      try {
	        try {
	          FORMATTERS[key] = new Intl.NumberFormat(formatLocales, props);
	        } catch (err) {
	          if (err.message.indexOf("Invalid language tag") >= 0) {
	            FORMATTERS[key] = new Intl.NumberFormat("en-US", props);
	          }
	        }
	      } catch (err) {
	        console.warn(err);
	      }
	      return FORMATTERS[key];
	    },
	    applyRounding(value, config) {
	      if (!config || !config.round) {
	        return value;
	      }
	      const scale = config.decimals;
	      const fraction = config.round_interval === "fraction" ? config.round_fraction || 0 : 0;
	      let roundValue = ~~value;
	      let decimalValue = this.round(value, scale);
	      if (decimalValue === fraction) {
	        return roundValue + decimalValue;
	      }
	      const diff = this.round(decimalValue - fraction, 1);
	      const direction = config.round === "nearest" ? diff > 0 ? diff >= 0.5 ? "up" : "down" : diff <= -0.5 ? "down" : "up" : config.round;
	      switch (direction) {
	        case "down":
	          roundValue = roundValue + fraction - (decimalValue > fraction ? 0 : 1);
	          break;
	        case "up":
	        default:
	          roundValue = roundValue + fraction + (decimalValue > fraction ? 1 : 0);
	          break;
	      }
	      return this.round(roundValue, scale);
	    },
	    round
	  };
	}

	var __defProp = Object.defineProperty;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	const options = {
	  store: null,
	  key: null,
	  url: null,
	  useCamelCase: null,
	  previewContent: null
	};
	const api = {
	  version: "3.21.2",
	  options,
	  request,
	  init(store, key, opt = {}) {
	    options.key = key;
	    options.store = store;
	    options.url = opt.url ? trimEnd(opt.url) : `https://${store}.swell.store`;
	    options.vaultUrl = opt.vaultUrl ? trimEnd(opt.vaultUrl) : `https://vault.schema.io`;
	    options.timeout = opt.timeout && parseInt(opt.timeout, 10) || 2e4;
	    options.useCamelCase = opt.useCamelCase || false;
	    options.previewContent = opt.previewContent || false;
	    options.session = opt.session;
	    options.locale = opt.locale;
	    options.currency = opt.currency;
	    options.api = api;
	    options.getCart = opt.getCart;
	    options.updateCart = opt.updateCart;
	    setOptions(options);
	  },
	  auth(...args) {
	    return this.init(...args);
	  },
	  get(url, query) {
	    return request("get", url, query);
	  },
	  put(url, data) {
	    return request("put", url, data);
	  },
	  post(url, data) {
	    return request("post", url, data);
	  },
	  delete(url, data) {
	    return request("delete", url, data);
	  },
	  cache: cacheApi,
	  card: cardApi,
	  cart: methods$8(request, options),
	  account: methods$7(request),
	  products: methods$9(request, options),
	  categories: methods$6(request),
	  attributes: methods$a(request),
	  subscriptions: methods$5(request),
	  invoices: methods$4(request),
	  content: methods$3(request, options),
	  settings: methods$2(request, options),
	  payment: new PaymentController(request, options),
	  locale: methods$1(request, options),
	  currency: methods(request, options),
	  utils
	};
	async function request(method, url, id = void 0, data = void 0, opt = void 0) {
	  const allOptions = __spreadValues(__spreadValues({}, options), opt);
	  const session = allOptions.session || getCookie("swell-session");
	  const locale2 = allOptions.locale || getCookie("swell-locale");
	  const currency2 = allOptions.currency || getCookie("swell-currency");
	  const baseUrl = `${allOptions.url}${allOptions.base || ""}/api`;
	  const reqMethod = String(method).toLowerCase();
	  let reqUrl = url;
	  let reqData = id;
	  if (data !== void 0 || typeof id === "string") {
	    reqUrl = [trimEnd(url), trimStart(id)].join("/");
	    reqData = data;
	  }
	  reqUrl = allOptions.fullUrl || `${baseUrl}/${trimBoth(reqUrl)}`;
	  reqData = allOptions.useCamelCase ? toSnake(reqData) : reqData;
	  let reqBody;
	  if (reqMethod === "get") {
	    let exQuery;
	    [reqUrl, exQuery] = reqUrl.split("?");
	    const fullQuery = [exQuery, stringifyQuery(reqData)].join("&").replace(/^&/, "");
	    reqUrl = `${reqUrl}${fullQuery ? `?${fullQuery}` : ""}`;
	  } else {
	    reqBody = JSON.stringify(reqData);
	  }
	  const reqHeaders = {
	    Accept: "application/json",
	    "Content-Type": "application/json",
	    Authorization: `Basic ${base64Encode(String(allOptions.key))}`
	  };
	  if (session) {
	    reqHeaders["X-Session"] = session;
	  }
	  if (locale2) {
	    reqHeaders["X-Locale"] = locale2;
	  }
	  if (currency2) {
	    reqHeaders["X-Currency"] = currency2;
	  }
	  const response = await fetch(reqUrl, {
	    method: reqMethod,
	    headers: reqHeaders,
	    body: reqBody,
	    credentials: "include",
	    mode: "cors"
	  });
	  const responseSession = response.headers.get("X-Session");
	  if (typeof responseSession === "string" && session !== responseSession) {
	    setCookie("swell-session", responseSession);
	  }
	  const result = await response.json();
	  if (result && result.error) {
	    const err = new Error(result.error.message);
	    err.status = response.status;
	    err.code = result.error.code;
	    err.param = result.error.param;
	    throw err;
	  } else if (!response.ok) {
	    const err = new Error(
	      "A connection error occurred while making the request"
	    );
	    err.code = "connection_error";
	    throw err;
	  }
	  return options.useCamelCase ? toCamel(result) : result;
	}

	return api;

}));
//# sourceMappingURL=swell.umd.min.js.map
